

----QUIT----(30 May 2023 00:05:32) CuisUniversity-5832.image priorSource: 4928100!

----STARTUP---- (30 May 2023 00:05:33) as /Users/hernan/Documents/Cuis/5.0-64Bits/Cuis-University-Installer/CuisUniversity-5832.image!


----QUIT----(30 May 2023 00:05:33) CuisUniversity-5832.image priorSource: 9366537!

----STARTUP---- (20 June 2023 15:03:33) as C:\Users\Santii\Desktop\UBA\inge1\windows64\CuisUniversity-5832.image!


----End fileIn of C:\Users\Santii\Desktop\UBA\inge1\windows64\Packages\System\Collections-CompactArrays.pck.st----!

----End fileIn of C:\Users\Santii\Desktop\UBA\inge1\windows64\Packages\Features\Compression.pck.st----!

----End fileIn of C:\Users\Santii\Desktop\UBA\inge1\windows64\Packages\Features\Sound.pck.st----!

----End fileIn of C:\Users\Santii\Desktop\UBA\inge1\windows64\Packages\Features\Cryptography-DigitalSignatures.pck.st----!

----End fileIn of C:\Users\Santii\Desktop\UBA\inge1\windows64\Packages\Features\Identities-UUID.pck.st----!

----End fileIn of C:\Users\Santii\Desktop\UBA\inge1\windows64\Packages\System\Network-Kernel.pck.st----!

----End fileIn of C:\Users\Santii\Desktop\UBA\inge1\windows64\WebClient.pck.st----!

----End fileIn of C:\Users\Santii\Desktop\UBA\inge1\windows64\TusLibros-Model Ejercicio it4.st----!

----End fileIn of C:\Users\Santii\Desktop\UBA\inge1\windows64\TusLibros-Tests Ejercicio it4.st----!

----End fileIn of C:\Users\Santii\Desktop\UBA\inge1\windows64\TusLibrosREST Ejercicio it4.st----!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #CreditCardTest #test01CreditCardNumberWithLessThan16DigitsIsNotValid stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardNumberWithMoreThan16DigitsIsNotValid stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #CreditCardTest #test03CreditCardNumberShouldBeDigitsOnly stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #CreditCardTest #test04NameCanNotBeEmpty stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #CreditCardTest #test05IsExpiredOnNextExpirationMonth stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #CreditCardTest #test06IsNotExpiredOnExpirationMonth stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #CreditCardTest #test07CanGetCreditCardInfoFromIt stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:05:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:05:06'!
FAILURE!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:05:08'!
FAILURE!
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'SF 6/20/2023 15:07:24' prior: 50661881!
bookPerformance: anItem

	| bookPerformance totalMoney totalSales aSemaphore |

	bookPerformance := Dictionary new.
	
	aSemaphore := Semaphore new.
	
	[ totalSales := self totalSalesOf: anItem.
	  aSemaphore signal.
	  ] fork.
	totalMoney := self totalMoneyRaisedBy: anItem.
	
	aSemaphore wait.	
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'SF 6/20/2023 15:08:10' prior: 50661922!
storePerformance

	| totalMoney totalSales performance aSemaphore |
	
	performance := Dictionary new.
	aSemaphore := Semaphore new.
	
	[ totalSales := self totalSales.
	  aSemaphore signal
	  ] fork.
	totalMoney := self totalMoneyRaised.
	
	aSemaphore wait.
	
	performance at: 'quantity' put: totalSales.
	performance at: 'total' put: totalMoney.
	performance at: 'summary' put: 'The store selled a total of ',totalSales asString, ' books and raised a total amount of money equal to: ', totalMoney asString.
	
	^performance
	

! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #CreditCardTest #test01CreditCardNumberWithLessThan16DigitsIsNotValid stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardNumberWithMoreThan16DigitsIsNotValid stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #CreditCardTest #test03CreditCardNumberShouldBeDigitsOnly stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #CreditCardTest #test04NameCanNotBeEmpty stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #CreditCardTest #test05IsExpiredOnNextExpirationMonth stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #CreditCardTest #test06IsNotExpiredOnExpirationMonth stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #CreditCardTest #test07CanGetCreditCardInfoFromIt stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:08:12'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:08:13'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:08:14'!
PASSED!

Object subclass: #ConcurrentClosureExecuter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!

!classDefinition: #ConcurrentClosureExecuter category: 'TusLibros-Model' stamp: 'SF 6/20/2023 15:10:54'!
Object subclass: #ConcurrentClosureExecuter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!

!classDefinition: #ConcurrentClosureExecuter category: 'TusLibros-Model' stamp: 'SF 6/20/2023 15:12:39'!
Object subclass: #ConcurrentClosureExecuter
	instanceVariableNames: 'concurrentClosures'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!
!ConcurrentClosureExecuter methodsFor: 'no messages' stamp: 'SF 6/20/2023 15:12:38'!
addClosureToRunConcurrently: aClosure

	concurrentClosures add: aClosure.! !
!ConcurrentClosureExecuter methodsFor: 'as yet unclassified' stamp: 'SF 6/20/2023 15:13:47'!
addBlockToRunAfter: aClosure

	concurrentClosures add: aClosure.! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #CreditCardTest #test01CreditCardNumberWithLessThan16DigitsIsNotValid stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardNumberWithMoreThan16DigitsIsNotValid stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #CreditCardTest #test03CreditCardNumberShouldBeDigitsOnly stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #CreditCardTest #test04NameCanNotBeEmpty stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #CreditCardTest #test05IsExpiredOnNextExpirationMonth stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #CreditCardTest #test06IsNotExpiredOnExpirationMonth stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #CreditCardTest #test07CanGetCreditCardInfoFromIt stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:13:48'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:13:49'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:13:50'!
PASSED!

!classDefinition: #ConcurrentClosureExecuter category: 'TusLibros-Model' stamp: 'SF 6/20/2023 15:14:15'!
Object subclass: #ConcurrentClosureExecuter
	instanceVariableNames: 'concurrentClosures block'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!
!ConcurrentClosureExecuter methodsFor: 'as yet unclassified' stamp: 'SF 6/20/2023 15:14:14'!
addBlockToRunAfterClosures: aBlock

	block := aBlock.! !

!methodRemoval: ConcurrentClosureExecuter #addBlockToRunAfter: stamp: 'SF 6/20/2023 15:14:21'!
addBlockToRunAfter: aClosure

	concurrentClosures add: aClosure.!
!ConcurrentClosureExecuter methodsFor: 'as yet unclassified' stamp: 'SF 6/20/2023 15:16:27' overrides: 16902254!
value

	| aSemaphore |
	
	aSemaphore := Semaphore new.
	
	concurrentClosures do: [ :aClosure | 
		aClosure value fork.
		aSemaphore signal
		].
	
	concurrentClosures size timesRepeat: [ aSemaphore wait ].
	
	block value.! !
!ConcurrentClosureExecuter methodsFor: 'as yet unclassified' stamp: 'SF 6/20/2023 15:17:12' prior: 50664435 overrides: 16902254!
value

	| aSemaphore |
	
	aSemaphore := Semaphore new.
	
	concurrentClosures do: [ :aClosure | 
		aClosure fork.
		aSemaphore signal.
		].
	
	concurrentClosures size timesRepeat: [ aSemaphore wait ].
	
	block value.! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'SF 6/20/2023 15:17:46' prior: 50664046!
bookPerformance: anItem

	| bookPerformance totalMoney totalSales aSemaphore anExecuter |

	bookPerformance := Dictionary new.
	
	anExecuter := ConcurrentClosureExecuter new initialize.
	
	aSemaphore := Semaphore new.
	
	[ totalSales := self totalSalesOf: anItem.
	  aSemaphore signal.
	  ] fork.
	totalMoney := self totalMoneyRaisedBy: anItem.
	
	aSemaphore wait.	
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !
!ConcurrentClosureExecuter methodsFor: 'as yet unclassified' stamp: 'SF 6/20/2023 15:18:05' overrides: 16920235!
initialize
	
	concurrentClosures := OrderedCollection new.! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'SF 6/20/2023 15:19:36' prior: 50664457!
bookPerformance: anItem

	| bookPerformance totalMoney totalSales anExecuter |

	bookPerformance := Dictionary new.
	
	anExecuter := ConcurrentClosureExecuter new initialize.
	
	anExecuter addClosureToRunConcurrently: [ totalSales := self totalSalesOf: anItem ].
	anExecuter addClosureToRunConcurrently: [ totalMoney := self totalMoneyRaisedBy: anItem ].

	anExecuter addBlockToRunAfterClosures: [	
		bookPerformance at: 'quantity' put: totalSales.
		bookPerformance at: 'total' put: totalMoney.
		bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	]

	^bookPerformance
	

! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'SF 6/20/2023 15:19:40'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'SF 6/20/2023 15:19:40'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #CreditCardTest #test01CreditCardNumberWithLessThan16DigitsIsNotValid stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardNumberWithMoreThan16DigitsIsNotValid stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #CreditCardTest #test03CreditCardNumberShouldBeDigitsOnly stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #CreditCardTest #test04NameCanNotBeEmpty stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #CreditCardTest #test05IsExpiredOnNextExpirationMonth stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #CreditCardTest #test06IsNotExpiredOnExpirationMonth stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #CreditCardTest #test07CanGetCreditCardInfoFromIt stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:19:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:19:41'!
ERROR!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:19:42'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:19:42'!
ERROR!
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'SF 6/20/2023 15:19:51' prior: 50664486!
bookPerformance: anItem

	| bookPerformance totalMoney totalSales anExecuter |

	bookPerformance := Dictionary new.
	
	anExecuter := ConcurrentClosureExecuter new initialize.
	
	anExecuter addClosureToRunConcurrently: [ totalSales := self totalSalesOf: anItem ].
	anExecuter addClosureToRunConcurrently: [ totalMoney := self totalMoneyRaisedBy: anItem ].

	anExecuter addBlockToRunAfterClosures: [	
		bookPerformance at: 'quantity' put: totalSales.
		bookPerformance at: 'total' put: totalMoney.
		bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	].

	^bookPerformance
	

! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'SF 6/20/2023 15:19:53'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'SF 6/20/2023 15:19:53'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'SF 6/20/2023 15:19:53'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'SF 6/20/2023 15:19:53'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'SF 6/20/2023 15:19:53'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #CreditCardTest #test01CreditCardNumberWithLessThan16DigitsIsNotValid stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardNumberWithMoreThan16DigitsIsNotValid stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #CreditCardTest #test03CreditCardNumberShouldBeDigitsOnly stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #CreditCardTest #test04NameCanNotBeEmpty stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #CreditCardTest #test05IsExpiredOnNextExpirationMonth stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #CreditCardTest #test06IsNotExpiredOnExpirationMonth stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #CreditCardTest #test07CanGetCreditCardInfoFromIt stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:19:54'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:19:54'!
ERROR!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:19:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:19:55'!
ERROR!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #CreditCardTest #test01CreditCardNumberWithLessThan16DigitsIsNotValid stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardNumberWithMoreThan16DigitsIsNotValid stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #CreditCardTest #test03CreditCardNumberShouldBeDigitsOnly stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #CreditCardTest #test04NameCanNotBeEmpty stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #CreditCardTest #test05IsExpiredOnNextExpirationMonth stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #CreditCardTest #test06IsNotExpiredOnExpirationMonth stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #CreditCardTest #test07CanGetCreditCardInfoFromIt stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:20:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:20:02'!
ERROR!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:20:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:20:03'!
ERROR!
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'SF 6/20/2023 15:21:14' prior: 50664663!
bookPerformance: anItem

	| bookPerformance totalMoney totalSales anExecuter |

	bookPerformance := Dictionary new.
	
	anExecuter := ConcurrentClosureExecuter new initialize.
	
	anExecuter addClosureToRunConcurrently: [ totalSales := self totalSalesOf: anItem ].
	anExecuter addClosureToRunConcurrently: [ totalMoney := self totalMoneyRaisedBy: anItem ].

	anExecuter addBlockToRunAfterClosures: [	
		bookPerformance at: 'quantity' put: totalSales.
		bookPerformance at: 'total' put: totalMoney.
		bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	].

	anExecuter value.

	^bookPerformance
	

! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #CreditCardTest #test01CreditCardNumberWithLessThan16DigitsIsNotValid stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardNumberWithMoreThan16DigitsIsNotValid stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #CreditCardTest #test03CreditCardNumberShouldBeDigitsOnly stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #CreditCardTest #test04NameCanNotBeEmpty stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #CreditCardTest #test05IsExpiredOnNextExpirationMonth stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #CreditCardTest #test06IsNotExpiredOnExpirationMonth stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #CreditCardTest #test07CanGetCreditCardInfoFromIt stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:21:18'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:21:18'!
FAILURE!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:21:19'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:21:19'!
FAILURE!
!ConcurrentClosureExecuter methodsFor: 'as yet unclassified' stamp: 'SF 6/20/2023 15:21:56' prior: 50664447 overrides: 16902254!
value

	| aSemaphore |
	
	aSemaphore := Semaphore new.
	
	concurrentClosures do: [ :aClosure | 
		aClosure fork.
		aSemaphore signal.
		].
	
	concurrentClosures size timesRepeat: [ aSemaphore wait ].
	
	block value.! !
!ConcurrentClosureExecuter methodsFor: 'as yet unclassified' stamp: 'SF 6/20/2023 15:23:46' prior: 50665169 overrides: 16902254!
value

	| aSemaphore |
	
	aSemaphore := Semaphore new.
	
	concurrentClosures do: [ :aClosure | 
		[ aClosure.
		aSemaphore signal ] fork.
		].
	
	concurrentClosures size timesRepeat: [ aSemaphore wait ].
	
	block value.! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #CreditCardTest #test01CreditCardNumberWithLessThan16DigitsIsNotValid stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardNumberWithMoreThan16DigitsIsNotValid stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #CreditCardTest #test03CreditCardNumberShouldBeDigitsOnly stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #CreditCardTest #test04NameCanNotBeEmpty stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #CreditCardTest #test05IsExpiredOnNextExpirationMonth stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #CreditCardTest #test06IsNotExpiredOnExpirationMonth stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #CreditCardTest #test07CanGetCreditCardInfoFromIt stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:23:52'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:23:52'!
FAILURE!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:23:53'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:23:53'!
FAILURE!
!ConcurrentClosureExecuter methodsFor: 'as yet unclassified' stamp: 'SF 6/20/2023 15:27:40' prior: 50665180 overrides: 16902254!
value

	| aSemaphore |
	
	aSemaphore := Semaphore new.
	
	concurrentClosures do: [ :aClosure | 
		[ aClosure value.
		aSemaphore signal ] fork.
		].
	
	concurrentClosures size timesRepeat: [ aSemaphore wait ].
	
	block value.! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #CreditCardTest #test01CreditCardNumberWithLessThan16DigitsIsNotValid stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardNumberWithMoreThan16DigitsIsNotValid stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #CreditCardTest #test03CreditCardNumberShouldBeDigitsOnly stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #CreditCardTest #test04NameCanNotBeEmpty stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #CreditCardTest #test05IsExpiredOnNextExpirationMonth stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #CreditCardTest #test06IsNotExpiredOnExpirationMonth stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #CreditCardTest #test07CanGetCreditCardInfoFromIt stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:27:45'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:27:46'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:27:47'!
PASSED!
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'SF 6/20/2023 15:28:30' prior: 50664991!
bookPerformance: anItem

	| bookPerformance totalMoney totalSales anExecuter |
	
	anExecuter := ConcurrentClosureExecuter new initialize.

	bookPerformance := Dictionary new.
	
	anExecuter addClosureToRunConcurrently: [ totalSales := self totalSalesOf: anItem ].
	anExecuter addClosureToRunConcurrently: [ totalMoney := self totalMoneyRaisedBy: anItem ].

	anExecuter addBlockToRunAfterClosures: [	
		bookPerformance at: 'quantity' put: totalSales.
		bookPerformance at: 'total' put: totalMoney.
		bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	].

	anExecuter value.

	^bookPerformance
	

! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'SF 6/20/2023 15:28:49' prior: 50664067!
storePerformance

	| totalMoney totalSales performance aSemaphore anExecuter |
	
	anExecuter := ConcurrentClosureExecuter new initialize.
	
	performance := Dictionary new.
	aSemaphore := Semaphore new.
	
	[ totalSales := self totalSales.
	  aSemaphore signal
	  ] fork.
	totalMoney := self totalMoneyRaised.
	
	aSemaphore wait.
	
	performance at: 'quantity' put: totalSales.
	performance at: 'total' put: totalMoney.
	performance at: 'summary' put: 'The store selled a total of ',totalSales asString, ' books and raised a total amount of money equal to: ', totalMoney asString.
	
	^performance
	

! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'SF 6/20/2023 15:30:20' prior: 50665527!
storePerformance

	| totalMoney totalSales performance anExecuter |
	
	anExecuter := ConcurrentClosureExecuter new initialize.
	
	performance := Dictionary new.
	
	anExecuter addClosureToRunConcurrently: [ totalSales := self totalSales ].
	anExecuter addClosureToRunConcurrently: [ totalMoney := self totalMoneyRaised ].
	
	anExecuter addBlockToRunAfterClosures: [
		performance at: 'quantity' put: totalSales.
		performance at: 'total' put: totalMoney.
		performance at: 'summary' put: 'The store selled a total of ',totalSales asString, ' books and raised a total amount of money equal to: ', totalMoney asString.
	].

	anExecuter value.

	^performance
	

! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #CreditCardTest #test01CreditCardNumberWithLessThan16DigitsIsNotValid stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardNumberWithMoreThan16DigitsIsNotValid stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #CreditCardTest #test03CreditCardNumberShouldBeDigitsOnly stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #CreditCardTest #test04NameCanNotBeEmpty stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #CreditCardTest #test05IsExpiredOnNextExpirationMonth stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #CreditCardTest #test06IsNotExpiredOnExpirationMonth stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #CreditCardTest #test07CanGetCreditCardInfoFromIt stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'SF 6/20/2023 15:30:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:30:23'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'SF 6/20/2023 15:30:24'!
PASSED!

----SNAPSHOT----(20 June 2023 15:31:19) CuisUniversity-5832.image priorSource: 9366758!

----SNAPSHOT----(20 June 2023 15:31:42) CuisUniversity-5832.image priorSource: 10690232!

TusLibrosServerRestInterface installForDefaultSystem!

TusLibrosClientTestWindow open!

TusLibrosClientTestWindow open!
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/20/2023 16:04:48' prior: 50663598!
addToCart

	| cartId bookIsbn |

	[
		(self areCartIdAndBookSelected) ifTrue:[
			cartId := self selectedCartId.
			bookIsbn := self selectedBook.
			restInterface add: 1 of: bookIsbn toCartIdentifiedAs: cartId.
			self triggerEvent: #bookAddedToCart withArguments: (Array with: bookIsbn with: cartId)]
	] fork.! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/20/2023 16:04:57' prior: 50663611!
createCart

	| newCartId |
	
	[
		newCartId := restInterface createCartFor: 'hernan' password: 'smalltalk'.
		cartIds add: newCartId.
		self triggerEvent: #newCartIdArrived
	] fork! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/20/2023 16:04:59' prior: 50665745!
createCart

	| newCartId |
	
	[
		newCartId := restInterface createCartFor: 'hernan' password: 'smalltalk'.
		cartIds add: newCartId.
		self triggerEvent: #newCartIdArrived
	] fork.! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/20/2023 16:05:10' prior: 50663620!
listCart

	| cartId |
	
	[
		(self isCartIdSelected) ifTrue:[
			cartId := self selectedCartId.
			currentSelectedCartContent := restInterface listCart: cartId.
			self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId ].
	] fork.! !

WebServer reset!

WebServer reset!

TusLibrosServerRestInterface installForDefaultSystem!

TusLibrosClientTestWindow open!
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/20/2023 16:10:00' prior: 50665765!
listCart

	| cartId |
	
	[
		(self isCartIdSelected) ifTrue:[
			cartId := self selectedCartId.
			
			[
				currentSelectedCartContent := restInterface listCart: cartId.
				self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
			] on: Error do: [ : anError | 
							
						]
			
			
			 ].
	] fork.! !
!TusLibrosClientTestWindow methodsFor: 'events' stamp: 'SF 6/20/2023 16:10:17'!
informError: anErrorDescription

	self inform: anErrorDescription
	
! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/20/2023 16:12:16' prior: 50665781!
listCart

	| cartId |
	
	[
		(self isCartIdSelected) ifTrue:[
			cartId := self selectedCartId.
			
			[ currentSelectedCartContent := restInterface listCart: cartId.
			  self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
			] on: Error
		          do: [ : anError | 
			      self triggerEvent: #informError with: anError messageText.
			  ]			
                ].
	] fork.! !
!TusLibrosClientTestWindow methodsFor: 'initialization' stamp: 'SF 6/20/2023 16:13:38' prior: 50663379!
initializeWith: aTitle

	self setLabel: aTitle.
	self model: (TusLibrosClientTestWindowModel new).
	self morphExtent: (self defaultExtent).
	self buildMorphicWindow.
	self openInWorld.
			
	self model when: #newCartIdArrived send: #refreshListOfCartIds to: self.		
	self model when: #selectedCartChanged send: #refreshCartButtonsLabels: to: self.	
	self model when: #bookAddedToCart send: #informBook:addedToCart: to: self.
	self model when: #newCurrentSelectedCartContentArrived send: #refreshCurrentSelectedCartContent: to: self.
	self model when: #errorRaised send: #informError: to: self.! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/20/2023 16:14:04' prior: 50665800!
listCart

	| cartId |
	
	[
		(self isCartIdSelected) ifTrue:[
			cartId := self selectedCartId.
			
			[ currentSelectedCartContent := restInterface listCart: cartId.
			  self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
			] on: Error
		          do: [ : anError | 
			      self triggerEvent: #errorRaised with: anError messageText.
			  ]			
                ].
	] fork.! !
!TusLibrosServerRestInterface methodsFor: 'rest interface' stamp: 'SF 6/20/2023 16:14:38' prior: 50663776!
listCart: aRequest

	| cartId |
	
	self error: 'lol'.

	(Delay forSeconds: 10) wait.
	
	self withFieldsOf: aRequest do: [ :requestFields |
		cartId := self cartIdFrom: requestFields ].
	
	self 
		answer: [(systemFacade listCartIdentifiedAs: cartId) asArray]
		to: aRequest 
! !

WebServer reset!

TusLibrosServerRestInterface installForDefaultSystem!

TusLibrosClientTestWindow open!
!TusLibrosServerRestInterface methodsFor: 'rest interface' stamp: 'SF 6/20/2023 16:17:27' prior: 50665855!
listCart: aRequest

	| cartId |

	(Delay forSeconds: 10) wait.
	
	self withFieldsOf: aRequest do: [ :requestFields |
		cartId := self cartIdFrom: requestFields ].
	
	self 
		answer: [(systemFacade listCartIdentifiedAs: cartId) asArray]
		to: aRequest 
! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/20/2023 16:21:21' prior: 50665839!
listCart

	| cartId |
	
	[
		(self isCartIdSelected) ifTrue:[
			cartId := self selectedCartId.
			
			[ currentSelectedCartContent := restInterface listCart: cartId.
			  self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
			] on: Error
		          do: [ : anError | 
			      self triggerEvent: #errorRaised with: anError messageText.
			]			
                ].
	] fork.! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/20/2023 16:23:05' prior: 50663500!
listCart: cartId

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
	
	^self error: resp content.
	"resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection] 
		ifFalse:[^self error: resp content]"! !

WebServer reset!

TusLibrosServerRestInterface installForDefaultSystem!

TusLibrosClientTestWindow open!
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/20/2023 16:25:08' prior: 50665883!
listCart

	| cartId |
	
	[
		(self isCartIdSelected) ifTrue:[
			cartId := self selectedCartId.
			
			[ currentSelectedCartContent := restInterface listCart: cartId.
			    self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
			] on: Error
		          do: [ : anError | 
			      self triggerEvent: #errorRaised with: anError messageText.
			]			
                ].
	] fork.! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/20/2023 16:25:14' prior: 50665917!
listCart

	| cartId |
	
	[
		(self isCartIdSelected) ifTrue:[
			cartId := self selectedCartId.
			
			[ currentSelectedCartContent := restInterface listCart: cartId.
			    self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
			] on: Error
		          do: [ : anError | 
			    self triggerEvent: #errorRaised with: anError messageText.
			]			
                ].
	] fork.! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/20/2023 16:25:34' prior: 50665899!
listCart: cartId

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
	
	^self error: 'error jajaja'.
	"resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection] 
		ifFalse:[^self error: resp content]"! !

WebServer reset!

TusLibrosServerRestInterface installForDefaultSystem!

TusLibrosClientTestWindow open!

WebServer reset!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/20/2023 16:27:10' prior: 50665949!
listCart: cartId

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
	
	resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection] 
		ifFalse:[^self error: resp content]! !

WebServer reset!

TusLibrosServerRestInterface installForDefaultSystem!

TusLibrosClientTestWindow open!

WebServer reset!
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/20/2023 16:29:26' prior: 50665755!
createCart

	| newCartId |
	
	[
		[       newCartId := restInterface createCartFor: 'hernan' password: 'smalltalk'.
			cartIds add: newCartId.
			self triggerEvent: #newCartIdArrived
		] on: Error
		  do: [ : anError | 
		      self triggerEvent: #errorRaised with: anError messageText.
		  ]	
	] fork.! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/20/2023 16:29:28' prior: 50665986!
createCart

	| newCartId |
	
	[
		[       newCartId := restInterface createCartFor: 'hernan' password: 'smalltalk'.
			cartIds add: newCartId.
			self triggerEvent: #newCartIdArrived
		] on: Error
		  do: [ : anError | 
		      self triggerEvent: #errorRaised with: anError messageText.
		  ]
	] fork.! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/20/2023 16:30:14' prior: 50665731!
addToCart

	| cartId bookIsbn |

	[
		(self areCartIdAndBookSelected) ifTrue:[
			[
			cartId := self selectedCartId.
			bookIsbn := self selectedBook.
			restInterface add: 1 of: bookIsbn toCartIdentifiedAs: cartId.
			self triggerEvent: #bookAddedToCart withArguments: (Array with: bookIsbn with: cartId)
			] on: Error
		          do: [ : anError | 
			    self triggerEvent: #errorRaised with: anError messageText.
			]
			]
	] fork.! !

WebServer reset!

WebServer reset!

TusLibrosServerRestInterface installForDefaultSystem!

TusLibrosClientTestWindow open!

WebServer reset!

WebServer reset!

TusLibrosServerRestInterface installForDefaultSystem!

TusLibrosClientTestWindow open!

WebServer reset!
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/20/2023 16:35:40' prior: 50665933!
listCart

	| cartId |
	
	[
		(self isCartIdSelected) ifTrue:[
			cartId := self selectedCartId.
			[ currentSelectedCartContent := restInterface listCart: cartId.
			    self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
			] on: Error
		          do: [ : anError | 
			    self triggerEvent: #errorRaised with: anError messageText.
			]			
                ].
	] fork.! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/20/2023 16:48:12'!
executeConcurrently: aClosure

	[self executeWithPopUpErrorHandling: aClosure] fork.! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/20/2023 16:49:11'!
executeWithPopUpErrorHandling: aClosure
	
	aClosure
		on: Error
		do: [ : anError | 
			self triggerEvent: #errorRaised with: anError messageText.
			]! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/20/2023 16:50:12' prior: 50665999!
createCart

	| newCartId |
	
	self executeConcurrently: [
		newCartId := restInterface createCartFor: 'hernan' password: 'smalltalk'.
		cartIds add: newCartId.
		self triggerEvent: #newCartIdArrived.
	].! !

WebServer reset!

TusLibrosServerRestInterface installForDefaultSystem!

WebServer reset!

TusLibrosServerRestInterface installForDefaultSystem!

TusLibrosClientTestWindow open!

WebServer reset!

WebServer reset.!

TusLibrosServerRestInterface installForDefaultSystem.!

TusLibrosClientTestWindow open.!

WebServer reset.!
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/20/2023 16:53:08' prior: 50666012!
addToCart

	| cartId bookIsbn |
	
	self executeConcurrently: [
		(self areCartIdAndBookSelected) ifTrue:[
			cartId := self selectedCartId.
			bookIsbn := self selectedBook.
			restInterface add: 1 of: bookIsbn toCartIdentifiedAs: cartId.
			self triggerEvent: #bookAddedToCart withArguments: (Array with: bookIsbn with: cartId)
		].
	].! !

WebServer reset.!

TusLibrosServerRestInterface installForDefaultSystem.!

TusLibrosClientTestWindow open.!

WebServer reset.!
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/20/2023 16:55:01' prior: 50666038!
listCart

	| cartId |
	
	self executeConcurrently: [
		(self isCartIdSelected) ifTrue: [
			cartId := self selectedCartId.
			currentSelectedCartContent := restInterface listCart: cartId.
			self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
		].
	].
	! !

WebServer reset.!

TusLibrosServerRestInterface installForDefaultSystem.!

TusLibrosClientTestWindow open.!

WebServer reset.!

----SNAPSHOT----(20 June 2023 16:56:48) CuisUniversity-5832.image priorSource: 10690321!

----STARTUP---- (21 June 2023 22:08:42) as C:\Users\Santii\Desktop\UBA\inge1\windows64\CuisUniversity-5832.image!


!methodRemoval: ConcurrentClosureExecuter #addBlockToRunAfterClosures: stamp: 'SF 6/21/2023 22:10:08'!
addBlockToRunAfterClosures: aBlock

	block := aBlock.!
!ConcurrentClosureExecuter methodsFor: 'as yet unclassified' stamp: 'SF 6/21/2023 22:10:17' prior: 50665343 overrides: 16902254!
value

	| aSemaphore |
	
	aSemaphore := Semaphore new.
	
	concurrentClosures do: [ :aClosure | 
		[ aClosure value.
		aSemaphore signal ] fork.
		].
	
	concurrentClosures size timesRepeat: [ aSemaphore wait ].! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'SF 6/21/2023 22:10:41' prior: 50665502!
bookPerformance: anItem

	| bookPerformance totalMoney totalSales anExecuter |
	
	anExecuter := ConcurrentClosureExecuter new initialize.

	bookPerformance := Dictionary new.
	
	anExecuter addClosureToRunConcurrently: [ totalSales := self totalSalesOf: anItem ].
	anExecuter addClosureToRunConcurrently: [ totalMoney := self totalMoneyRaisedBy: anItem ].

	anExecuter value.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'SF 6/21/2023 22:10:57' prior: 50665549!
storePerformance

	| totalMoney totalSales performance anExecuter |
	
	anExecuter := ConcurrentClosureExecuter new initialize.
	
	performance := Dictionary new.
	
	anExecuter addClosureToRunConcurrently: [ totalSales := self totalSales ].
	anExecuter addClosureToRunConcurrently: [ totalMoney := self totalMoneyRaised ].
	
	anExecuter value.
	
	performance at: 'quantity' put: totalSales.
	performance at: 'total' put: totalMoney.
	performance at: 'summary' put: 'The store selled a total of ',totalSales asString, ' books and raised a total amount of money equal to: ', totalMoney asString.

	^performance
	

! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'SF 6/21/2023 22:11:00'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'SF 6/21/2023 22:11:00'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'SF 6/21/2023 22:11:00'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'SF 6/21/2023 22:11:00'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'SF 6/21/2023 22:11:00'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'SF 6/21/2023 22:11:00'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'SF 6/21/2023 22:11:00'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'SF 6/21/2023 22:11:00'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'SF 6/21/2023 22:11:00'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'SF 6/21/2023 22:11:00'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'SF 6/21/2023 22:11:00'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'SF 6/21/2023 22:11:00'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'SF 6/21/2023 22:11:00'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'SF 6/21/2023 22:11:00'!
PASSED!

!testRun: #CreditCardTest #test01CreditCardNumberWithLessThan16DigitsIsNotValid stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardNumberWithMoreThan16DigitsIsNotValid stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #CreditCardTest #test03CreditCardNumberShouldBeDigitsOnly stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #CreditCardTest #test04NameCanNotBeEmpty stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #CreditCardTest #test05IsExpiredOnNextExpirationMonth stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #CreditCardTest #test06IsNotExpiredOnExpirationMonth stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #CreditCardTest #test07CanGetCreditCardInfoFromIt stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'SF 6/21/2023 22:11:01'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'SF 6/21/2023 22:11:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'SF 6/21/2023 22:11:03'!
PASSED!

----SNAPSHOT----(21 June 2023 22:12:49) CuisUniversity-5832.image priorSource: 10703154!

----STARTUP---- (22 June 2023 18:51:35) as /home/clinux01/Descargas/linux64/linux64/CuisUniversity-5832.image!


----End fileIn of /home/clinux01/Descargas/linux64/linux64/Packages/System/Collections-CompactArrays.pck.st----!

----End fileIn of /home/clinux01/Descargas/linux64/linux64/Packages/Features/Compression.pck.st----!

----End fileIn of /home/clinux01/Descargas/linux64/linux64/Packages/Features/Sound.pck.st----!

----End fileIn of /home/clinux01/Descargas/linux64/linux64/Packages/Features/Cryptography-DigitalSignatures.pck.st----!

----End fileIn of /home/clinux01/Descargas/linux64/linux64/Packages/Features/Identities-UUID.pck.st----!

----End fileIn of /home/clinux01/Descargas/linux64/linux64/Packages/System/Network-Kernel.pck.st----!

----End fileIn of /home/clinux01/Descargas/linux64/linux64/WebClient.pck.st----!

----End fileIn of /home/clinux01/Descargas/linux64/linux64/TusLibros-Model.st----!

----End fileIn of /home/clinux01/Descargas/linux64/linux64/TusLibrosREST.st----!

----End fileIn of /home/clinux01/Descargas/linux64/linux64/TusLibros-Tests.st----!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 18:53:41'!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId onSuccessDo: successBlock

	| fieldDict resp |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
		
	resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
		
	resp isSuccess 
		ifTrue:[ successBlock value: (WebUtils jsonDecode: ((resp content) readStream))]
		ifFalse:[^self error: resp content]! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 18:54:50' prior: 50662480!
addToCart

	| cartId bookIsbn |
	
	self executeConcurrently: [
		(self areCartIdAndBookSelected) ifTrue:[
			cartId := self selectedCartId.
			bookIsbn := self selectedBook.
			restInterface add: 1 of: bookIsbn toCartIdentifiedAs: cartId onSuccessDo: [ :status |
				self triggerEvent: #bookAddedToCart withArguments: (Array with: bookIsbn with: cartId)
			].
		].
	].! !

TusLibrosServerRestInterface installForDefaultSystem!

TusLibrosClientTestWindow open!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 18:57:04' prior: 50663965!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId onSuccessDo: successBlock

	| fieldDict resp |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
		
	resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
		
	resp isSuccess
		ifTrue:[ successBlock value: (WebUtils jsonDecode: ((resp content) readStream))]
		ifFalse:[^self error: resp content]! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 18:57:17' prior: 50662353!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId

	| fieldDict resp |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
		
	resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
		
	resp isSuccess
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream))]
		ifFalse:[^self error: resp content]! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 18:57:31'!
createCartFor: aUser password: aPassword onSuccessDo: successBlock

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
		
	resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream))] 
		ifFalse:[^self error: resp content]! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 18:57:39' prior: 50664032!
createCartFor: aUser password: aPassword onSuccessDo: successBlock

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
		
	resp isSuccess 
		ifTrue:[ successBlock value: (WebUtils jsonDecode: ((resp content) readStream))]
		ifFalse:[^self error: resp content]! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 18:57:41' prior: 50664047!
createCartFor: aUser password: aPassword onSuccessDo: successBlock

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
		
	resp isSuccess 
		ifTrue:[ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
		ifFalse:[^self error: resp content]! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 18:57:45' prior: 50664000!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId onSuccessDo: successBlock

	| fieldDict resp |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
		
	resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
		
	resp isSuccess
		ifTrue:[ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
		ifFalse:[^self error: resp content]! !

!methodRemoval: TusLibrosClientTestWindowModel #executeConcurrently: stamp: 'SF 6/22/2023 18:57:52'!
executeConcurrently: aClosure

	[self executeWithPopUpErrorHandling: aClosure] fork.!

!methodRemoval: TusLibrosClientTestWindowModel #executeWithPopUpErrorHandling: stamp: 'SF 6/22/2023 18:57:53'!
executeWithPopUpErrorHandling: aClosure
	
	aClosure
		on: Error
		do: [ : anError | 
			self triggerEvent: #errorRaised with: anError messageText.
			]!
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 18:58:03' prior: 50662494!
createCart

	| newCartId |
	
	newCartId := restInterface createCartFor: 'hernan' password: 'smalltalk'.
	cartIds add: newCartId.
	self triggerEvent: #newCartIdArrived.
	! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 18:58:13' prior: 50663982!
addToCart

	| cartId bookIsbn |
	
	(self areCartIdAndBookSelected) ifTrue:[
		cartId := self selectedCartId.
		bookIsbn := self selectedBook.
		restInterface add: 1 of: bookIsbn toCartIdentifiedAs: cartId onSuccessDo: [ :status |
			self triggerEvent: #bookAddedToCart withArguments: (Array with: bookIsbn with: cartId)
		].
	].
	! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 18:58:20' prior: 50662518!
listCart

	| cartId |
	
	(self isCartIdSelected) ifTrue: [
		cartId := self selectedCartId.
		currentSelectedCartContent := restInterface listCart: cartId.
		self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
	].
	
	! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 18:58:36' prior: 50664111!
createCart

	| newCartId |
	
	newCartId := restInterface createCartFor: 'hernan' password: 'smalltalk' onSuccessDo: [].
	cartIds add: newCartId.
	self triggerEvent: #newCartIdArrived.
	! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 19:00:20' prior: 50664145!
createCart

	| newCartId |
	
	newCartId := restInterface createCartFor: 'hernan' password: 'smalltalk' onSuccessDo: [
		cartIds add: newCartId.
		self triggerEvent: #newCartIdArrived.
	].
	
	! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 19:00:47' prior: 50664155!
createCart

	restInterface createCartFor: 'hernan' password: 'smalltalk' onSuccessDo: [ :newCartID |
		cartIds add: newCartID.
		self triggerEvent: #newCartIdArrived.
	].
	
	! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:01:27' prior: 50664079!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId onSuccessDo: successBlock

	| fieldDict resp |

	[
		fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
			
		resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
			
		resp isSuccess
			ifTrue:[ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
			ifFalse:[^self error: resp content]
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:01:38' prior: 50664063!
createCartFor: aUser password: aPassword onSuccessDo: successBlock

	| fieldDict resp |
	
	[
		fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
		
		resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
			
		resp isSuccess 
			ifTrue:[ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
			ifFalse:[^self error: resp content]
	] fork! !

!methodRemoval: TusLibrosClientRestInterface #createCartFor:password: stamp: 'SF 6/22/2023 19:02:15'!
createCartFor: aUser password: aPassword

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
		
	resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream))] 
		ifFalse:[^self error: resp content]!

!methodRemoval: TusLibrosClientRestInterface #add:of:toCartIdentifiedAs: stamp: 'SF 6/22/2023 19:02:18'!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId

	| fieldDict resp |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
		
	resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
		
	resp isSuccess
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream))]
		ifFalse:[^self error: resp content]!
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 19:03:40' prior: 50664134!
listCart

	| cartId |
	
	(self isCartIdSelected) ifTrue: [
		cartId := self selectedCartId.
		currentSelectedCartContent := restInterface listCart: cartId onSuccessDo: [ :status | 
			self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
		] asOrderedCollection.
	].
	
	! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:03:51' prior: 50662382!
listCart: cartId

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
	
	resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream))] 
		ifFalse:[^self error: resp content]! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:04:06'!
listCart: cartId onSuccessDo: successBlock

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
	
	resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream))] 
		ifFalse:[^self error: resp content]! !

!methodRemoval: TusLibrosClientRestInterface #listCart: stamp: 'SF 6/22/2023 19:04:10'!
listCart: cartId

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
	
	resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream))] 
		ifFalse:[^self error: resp content]!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:04:28' prior: 50664192!
createCartFor: aUser password: aPassword onSuccessDo: successBlock

	| fieldDict resp |
	
	[
		fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
		
		resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
			
		resp isSuccess 
			ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
			ifFalse: [ ^self error: resp content ]
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:04:36' prior: 50664264!
listCart: cartId onSuccessDo: successBlock

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
	
	resp isSuccess 
		ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
		ifFalse:[^self error: resp content]! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:04:40' prior: 50664307!
listCart: cartId onSuccessDo: successBlock

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
	
	resp isSuccess 
		ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
		ifFalse:[ ^self error: resp content ]! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:04:48' prior: 50664174!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId onSuccessDo: successBlock

	| fieldDict resp |

	[
		fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
			
		resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
			
		resp isSuccess
			ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
			ifFalse: [ ^self error: resp content ]
	] fork! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 19:05:29' prior: 50664120!
addToCart

	| cartId bookIsbn |
	
	(self areCartIdAndBookSelected) ifTrue:[
		cartId := self selectedCartId.
		bookIsbn := self selectedBook.
		restInterface
			add: 1
			of: bookIsbn
			toCartIdentifiedAs: cartId
			onSuccessDo: [ :status |
				self triggerEvent: #bookAddedToCart withArguments: (Array with: bookIsbn with: cartId)
			].
		].
	! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 19:05:50' prior: 50664355!
addToCart

	| cartId bookIsbn |
	
	(self areCartIdAndBookSelected) ifTrue:[
		cartId := self selectedCartId.
		bookIsbn := self selectedBook.
		restInterface add: 1 of: bookIsbn toCartIdentifiedAs: cartId
			onSuccessDo: [ :status |
				self triggerEvent: #bookAddedToCart withArguments: (Array with: bookIsbn with: cartId)
			].
		].
	! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 19:05:59' prior: 50664165!
createCart

	restInterface createCartFor: 'hernan' password: 'smalltalk'
		onSuccessDo: [ :newCartID |
			cartIds add: newCartID.
			self triggerEvent: #newCartIdArrived.
		].
	
	! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 19:06:07' prior: 50664238!
listCart

	| cartId |
	
	(self isCartIdSelected) ifTrue: [
		cartId := self selectedCartId.
		currentSelectedCartContent := restInterface listCart: cartId
			onSuccessDo: [ :status | 
				self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
			] asOrderedCollection.
	].
	
	! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 19:06:09' prior: 50664395!
listCart

	| cartId |
	
	(self isCartIdSelected) ifTrue: [
		cartId := self selectedCartId.
		currentSelectedCartContent := restInterface listCart: cartId
			onSuccessDo: [ :status | 
				self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
			] asOrderedCollection.
		].
	
	! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:06:26' prior: 50664322!
listCart: cartId onSuccessDo: successBlock

	| fieldDict resp |
	
	[
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
	
	resp isSuccess 
		ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
		ifFalse:[ ^self error: resp content ]
	] fork! !
!TusLibrosClientTestWindowModel methodsFor: 'listSelectors' stamp: 'SF 6/22/2023 19:06:53' prior: 50662458!
cartContent

	^ currentSelectedCartContent! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 19:07:22' prior: 50664408!
listCart

	| cartId |
	
	(self isCartIdSelected) ifTrue: [
		cartId := self selectedCartId.
		currentSelectedCartContent := (restInterface listCart: cartId
			onSuccessDo: [ :status | 
				self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
			]) asOrderedCollection.
		].
	
	! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 19:07:58' prior: 50664441!
listCart

	| cartId |
	
	(self isCartIdSelected) ifTrue: [
		cartId := self selectedCartId.
		currentSelectedCartContent := restInterface listCart: cartId
			onSuccessDo: [ :status | 
				self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
			].
		].
	
	! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:08:04' prior: 50664421!
listCart: cartId onSuccessDo: successBlock

	| fieldDict resp |
	
	[
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
	
	resp isSuccess 
		ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection.]
		ifFalse:[ ^self error: resp content ]
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:08:06' prior: 50664466!
listCart: cartId onSuccessDo: successBlock

	| fieldDict resp |
	
	[
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
	
	resp isSuccess 
		ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection ]
		ifFalse:[ ^self error: resp content ]
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:09:13' prior: 50664482!
listCart: cartId onSuccessDo: successBlock

	| fieldDict resp |
	
	[
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
	
	resp isSuccess 
		ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection ]
		ifFalse:[ ^self error: resp content ]
	] fork! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 19:11:34' prior: 50664454!
listCart

	| cartId |
	
	(self isCartIdSelected) ifTrue: [
		cartId := self selectedCartId.
		restInterface listCart: cartId
			onSuccessDo: [ :response |
				currentSelectedCartContent := response. 
				self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
			].
		].
	
	! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 19:11:39' prior: 50664385!
createCart

	restInterface createCartFor: 'hernan' password: 'smalltalk'
		onSuccessDo: [ :response |
			cartIds add: response.
			self triggerEvent: #newCartIdArrived.
		].
	
	! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 19:11:43' prior: 50664370!
addToCart

	| cartId bookIsbn |
	
	(self areCartIdAndBookSelected) ifTrue:[
		cartId := self selectedCartId.
		bookIsbn := self selectedBook.
		restInterface add: 1 of: bookIsbn toCartIdentifiedAs: cartId
			onSuccessDo: [ :response |
				self triggerEvent: #bookAddedToCart withArguments: (Array with: bookIsbn with: cartId)
			].
		].
	! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:12:21' prior: 50664498!
listCart: cartId onSuccessDo: successBlock

	| fieldDict resp |
	
	[
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
	
	resp isSuccess 
		ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
		ifFalse:[ ^self error: resp content ]
	] fork! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 19:12:30' prior: 50664514!
listCart

	| cartId |
	
	(self isCartIdSelected) ifTrue: [
		cartId := self selectedCartId.
		restInterface listCart: cartId
			onSuccessDo: [ :response |
				currentSelectedCartContent := response asOrderedCollection. 
				self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
			].
		].
	
	! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:13:15' prior: 50664290!
createCartFor: aUser password: aPassword onSuccessDo: successBlock

	| fieldDict resp |
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	[
		
		
		resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
			
		resp isSuccess 
			ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
			ifFalse: [ ^self error: resp content ]
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:13:27' prior: 50664579!
createCartFor: aUser password: aPassword onSuccessDo: successBlock

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	[
		resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
			
		resp isSuccess 
			ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
			ifFalse: [ ^self error: resp content ]
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:13:35' prior: 50664551!
listCart: cartId onSuccessDo: successBlock

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	[
	resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
	
	resp isSuccess 
		ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
		ifFalse:[ ^self error: resp content ]
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:13:51' prior: 50664337!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId onSuccessDo: successBlock

	| fieldDict resp |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
	
	[	
		resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
			
		resp isSuccess
			ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
			ifFalse: [ ^self error: resp content ]
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:13:56' prior: 50664613!
listCart: cartId onSuccessDo: successBlock

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	[
		resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
		
		resp isSuccess 
			ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
			ifFalse:[ ^self error: resp content ]
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:14:49' prior: 50664646!
listCart: cartId onSuccessDo: successBlock

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	[
		resp := WebClient htmlSubmit: (self url, '/listCart') fields: fieldDict.
		
		resp isSuccess 
			ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
			ifFalse:[ ^self error: resp content ]
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:14:52' prior: 50664596!
createCartFor: aUser password: aPassword onSuccessDo: successBlock

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	[
		resp := WebClient htmlSubmit: (self url, '/createCart') fields: fieldDict.
			
		resp isSuccess 
			ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
			ifFalse: [ ^self error: resp content ]
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:14:55' prior: 50664628!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId onSuccessDo: successBlock

	| fieldDict resp |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
	
	[	
		resp := WebClient htmlSubmit: (self url, '/addToCart') fields: fieldDict.
			
		resp isSuccess
			ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
			ifFalse: [ ^self error: resp content ]
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:16:39' prior: 50664661!
listCart: cartId onSuccessDo: successBlock

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	[
		resp := WebClient htmlSubmit: (self url, '/listCart') fields: fieldDict.
		
		resp isSuccess 
			ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
			ifFalse: [ ^self error: resp content ]
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:18:05' prior: 50664693!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId onSuccessDo: successBlock

	| fieldDict resp |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
	
	self submitToRoute: '/addToCart' fields: fieldDict.
	
	[	
		resp := WebClient htmlSubmit: (self url, '/addToCart') fields: fieldDict.
			
		resp isSuccess
			ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
			ifFalse: [ ^self error: resp content ]
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:19:08'!
submitToRoute: aRoute fields: fieldDict withSuccessBlock: successBlock
	
	| resp |
	
	[	
		resp := WebClient htmlSubmit: (self url, aRoute) fields: fieldDict.
			
		resp isSuccess
			ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
			ifFalse: [ ^self error: resp content ]
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:19:28' prior: 50664726!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId onSuccessDo: successBlock

	| fieldDict |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
	
	self submitToRoute: '/addToCart' fields: fieldDict withSuccessBlock: successBlock.
	"
	[	
		resp := WebClient htmlSubmit: (self url, '/addToCart') fields: fieldDict.
			
		resp isSuccess
			ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
			ifFalse: [ ^self error: resp content ]
	] fork
"! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:19:51' prior: 50664759!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId onSuccessDo: successBlock

	| fieldDict |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
	
	self submitToRoute: '/addToCart'
		fields: fieldDict
		withSuccessBlock: successBlock.! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:19:54' prior: 50664779!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId onSuccessDo: successBlock

	| fieldDict |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
	
	self  submitToRoute: '/addToCart'
		fields: fieldDict
		withSuccessBlock: successBlock.! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:20:21' prior: 50664676!
createCartFor: aUser password: aPassword onSuccessDo: successBlock

	| fieldDict |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	self  submitToRoute: '/createCart'
		fields: fieldDict
		withSuccessBlock: successBlock.! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:20:41' prior: 50664711!
listCart: cartId onSuccessDo: successBlock

	| fieldDict |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	self  submitToRoute: '/listCart'
		fields: fieldDict
		withSuccessBlock: successBlock.! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 19:23:58' prior: 50664537!
addToCart

	| cartId bookIsbn |
	
	(self areCartIdAndBookSelected) ifTrue:[
		cartId := self selectedCartId.
		bookIsbn := self selectedBook.
		restInterface add: 1 of: bookIsbn toCartIdentifiedAs: cartId
			onSuccessDo: [ :response |
				self triggerEvent: #bookAddedToCart withArguments: (Array with: bookIsbn with: cartId)
				]
			onErrorDo: [ :response |
				self triggerEvent: #errorRaised withArguments: response
				].
		].
	! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:24:30'!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId onSuccessDo: successBlock onErrorDo: errorBlock

	| fieldDict |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
	
	self  submitToRoute: '/addToCart'
		fields: fieldDict
		withSuccessBlock: successBlock
		withErrorBlock: errorBlock.! !

!methodRemoval: TusLibrosClientRestInterface #add:of:toCartIdentifiedAs:onSuccessDo: stamp: 'SF 6/22/2023 19:24:33'!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId onSuccessDo: successBlock

	| fieldDict |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
	
	self  submitToRoute: '/addToCart'
		fields: fieldDict
		withSuccessBlock: successBlock.!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:25:04'!
submitToRoute: aRoute fields: fieldDict withSuccessBlock: successBlock withErrorBlock: errorBlock
	
	| resp |
	
	[	
		resp := WebClient htmlSubmit: (self url, aRoute) fields: fieldDict.
			
		resp isSuccess
			ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
			ifFalse: [ errorBlock value: 'a']
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:25:27' prior: 50664872!
submitToRoute: aRoute fields: fieldDict withSuccessBlock: successBlock withErrorBlock: errorBlock
	
	| resp |
	
	[	
		resp := WebClient htmlSubmit: (self url, aRoute) fields: fieldDict.
			
		resp isSuccess
			ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
			ifFalse: [ errorBlock value: resp content ]
	] fork! !

!methodRemoval: TusLibrosClientRestInterface #submitToRoute:fields:withSuccessBlock: stamp: 'SF 6/22/2023 19:25:35'!
submitToRoute: aRoute fields: fieldDict withSuccessBlock: successBlock
	
	| resp |
	
	[	
		resp := WebClient htmlSubmit: (self url, aRoute) fields: fieldDict.
			
		resp isSuccess
			ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
			ifFalse: [ ^self error: resp content ]
	] fork!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:26:05'!
createCartFor: aUser password: aPassword onSuccessDo: successBlock onErrorDo: errorBlock

	| fieldDict |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	self  submitToRoute: '/createCart'
		fields: fieldDict
		onSuccessDo: successBlock
		onErrorDo: errorBlock.! !

!methodRemoval: TusLibrosClientRestInterface #createCartFor:password:onSuccessDo: stamp: 'SF 6/22/2023 19:26:09'!
createCartFor: aUser password: aPassword onSuccessDo: successBlock

	| fieldDict |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	self  submitToRoute: '/createCart'
		fields: fieldDict
		withSuccessBlock: successBlock.!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:26:29'!
listCart: cartId onSuccessDo: successBlock onErrorDo: errorBlock

	| fieldDict |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	self  submitToRoute: '/listCart'
		fields: fieldDict
		onSuccessDo: successBlock
		onErrorDo: errorBlock.! !

!methodRemoval: TusLibrosClientRestInterface #listCart:onSuccessDo: stamp: 'SF 6/22/2023 19:26:32'!
listCart: cartId onSuccessDo: successBlock

	| fieldDict |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	self  submitToRoute: '/listCart'
		fields: fieldDict
		withSuccessBlock: successBlock.!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:26:44'!
submitToRoute: aRoute fields: fieldDict onSuccessDo: successBlock onErrorDo: errorBlock
	
	| resp |
	
	[	
		resp := WebClient htmlSubmit: (self url, aRoute) fields: fieldDict.
			
		resp isSuccess
			ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
			ifFalse: [ errorBlock value: resp content ]
	] fork! !

!methodRemoval: TusLibrosClientRestInterface #submitToRoute:fields:withSuccessBlock:withErrorBlock: stamp: 'SF 6/22/2023 19:26:46'!
submitToRoute: aRoute fields: fieldDict withSuccessBlock: successBlock withErrorBlock: errorBlock
	
	| resp |
	
	[	
		resp := WebClient htmlSubmit: (self url, aRoute) fields: fieldDict.
			
		resp isSuccess
			ifTrue: [ successBlock value: (WebUtils jsonDecode: ((resp content) readStream)) ]
			ifFalse: [ errorBlock value: resp content ]
	] fork!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'SF 6/22/2023 19:26:59' prior: 50664845!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId onSuccessDo: successBlock onErrorDo: errorBlock

	| fieldDict |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
	
	self  submitToRoute: '/addToCart'
		fields: fieldDict
		onSuccessDo: successBlock
		onErrorDo: errorBlock.! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 19:27:28' prior: 50664527!
createCart

	restInterface createCartFor: 'hernan' password: 'smalltalk'
		onSuccessDo: [ :response |
			cartIds add: response.
			self triggerEvent: #newCartIdArrived.
		]
		onErrorDo: [ :response |
			self triggerEvent: #errorRaised withArguments: response
		]
	
	! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'SF 6/22/2023 19:27:36' prior: 50664566!
listCart

	| cartId |
	
	(self isCartIdSelected) ifTrue: [
		cartId := self selectedCartId.
		restInterface listCart: cartId
			onSuccessDo: [ :response |
				currentSelectedCartContent := response asOrderedCollection. 
				self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
			]
			onErrorDo: [ :response |
				self triggerEvent: #errorRaised withArguments: response
			].
		].
	
	! !

TusLibrosServerRestInterface reset!

WebServer reset!

----STARTUP---- (22 June 2023 20:03:51) as /home/clinux01/Descargas/linux64/linux64/CuisUniversity-5832.image!


----End fileIn of /home/clinux01/Descargas/2023-1c/10-CustomerImporter/CustomerImporter.st----!
!Customer methodsFor: 'importing' stamp: 'SF 6/22/2023 20:24:04'!
importCustomers

	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !

!methodRemoval: Customer class #importCustomers stamp: 'SF 6/22/2023 20:24:04'!
importCustomers

	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:24:41'!
importCustomers

	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !

!methodRemoval: Customer #importCustomers stamp: 'SF 6/22/2023 20:24:46'!
importCustomers

	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:24:51' prior: 50665048!
test01Import

	self importCustomers ! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:25:41' prior: 50665388!
importCustomers

	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:31:42' prior: 50665473!
importCustomers

	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !

!classDefinition: #ImportTest category: 'CustomerImporter' stamp: 'SF 6/22/2023 20:31:42'!
TestCase subclass: #ImportTest
	instanceVariableNames: 'session'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:32:27' overrides: 16961394!
setUp

	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:32:27' prior: 50665513!
importCustomers

	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	self setUp.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:32:58' prior: 50665567!
importCustomers

	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 20:33:37'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:34:00' prior: 50665604!
importCustomers

	| inputStream newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:34:16' overrides: 16961402!
tearDown

	session commit.
	session close! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:34:16' prior: 50665643!
importCustomers

	| inputStream newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	self tearDown.

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:34:26' prior: 50665685!
importCustomers

	| inputStream newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	inputStream close.
	! !

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 20:38:17'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:44:49' prior: 50665468!
test01Import

	self importCustomers.
	self assert: 5 equals: 5! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:45:19' prior: 50665759!
test01Import

	self importCustomers.
	self assert: 5 equals: (session objectsOfType: Customer).! !

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 20:45:21'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:45:27' prior: 50665764!
test01Import

	self importCustomers.
	self assert: 5 equals: (session objectsOfType: Customer) size.! !

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 20:45:28'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:45:58' prior: 50665773!
test01Import

	self importCustomers.
	self assert: 3 equals: (session objectsOfType: Address) size.
	self assert: 2 equals: (session objectsOfType: Customer) size.! !

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 20:45:59'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:48:25' prior: 50665721!
importCustomers

	| inputStream newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber.
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber.
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:49:06' prior: 50665793!
importCustomers

	| inputStream newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber.
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber.
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	inputStream close.
	! !

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 20:49:09'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:50:51' prior: 50665782!
test01Import

	self importCustomers.
	self assert: 2 equals: (session objectsOfType: Customer) size.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:50:59' prior: 50665866!
test01Import

	self importCustomers.
	"self assert: 3 equals: (session objectsOfType: Address) size."
	self assert: 2 equals: (session objectsOfType: Customer) size.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:52:14' prior: 50665873!
test01Import

	self importCustomers.
	"self assert: 3 equals: (session objectsOfType: Address) size."
	self assert: 2 equals: (session selectAllOfType: Customer) size.! !

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 20:52:15'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 20:52:16'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:52:27' prior: 50665882!
test01Import

	self importCustomers.
	self assert: 3 equals: (session selectAllOfType: Address) size.
	self assert: 2 equals: (session selectAllOfType: Customer) size.! !

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 20:52:28'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:53:39' prior: 50665896!
test01Import

	self importCustomers.
	self assert: 3 equals: (session selectAllOfType: Customer) sum: [:aCustomer | aCustomer].
	self assert: 2 equals: (session selectAllOfType: Customer) size.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:53:51' prior: 50665907!
test01Import

	self importCustomers.
	self assert: 3 equals: (session selectAllOfType: Customer) sum: [:aCustomer | aCustomer addresses].
	self assert: 2 equals: (session selectAllOfType: Customer) size.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:54:38' prior: 50665917!
test01Import

	self importCustomers.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [:aCustomer | aCustomer addresses] size).
	self assert: 2 equals: (session selectAllOfType: Customer) size.! !

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 20:54:41'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 20:54:42'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:54:54' prior: 50665927!
test01Import

	self importCustomers.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [:aCustomer | aCustomer addresses size] ).
	self assert: 2 equals: (session selectAllOfType: Customer) size.! !

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 20:55:01'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:55:18' prior: 50665942!
test01Import

	self importCustomers.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :aCustomer | aCustomer addresses size] ).
	self assert: 2 equals: (session selectAllOfType: Customer) size.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:55:23' prior: 50665955!
test01Import

	self importCustomers.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :aCustomer | aCustomer addresses size ] ).
	self assert: 2 equals: (session selectAllOfType: Customer) size.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 20:55:59' prior: 50665965!
test01Import

	self importCustomers.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :aCustomer | aCustomer addresses size ] ).
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:02:07' prior: 50665975!
test01Import

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :aCustomer | aCustomer addresses size ] ).
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:04:39'!
test02

	| aCustomer |
	
	self importCustomers.
	
	aCustomer := session select: [ :customer | customer identificationNumber = 22333444 ].
	
	self assert: 1 equals: aCustomer size.
	
	! !

!testRun: #ImportTest #test02 stamp: 'SF 6/22/2023 21:04:41'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:04:53' prior: 50665995!
test02

	| aCustomer |
	
	self importCustomers.
	
	aCustomer := session select: [ :customer | customer identificationNumber = 22333444 ] ofType: Customer.
	
	self assert: 1 equals: aCustomer size.
	
	! !

!testRun: #ImportTest #test02 stamp: 'SF 6/22/2023 21:04:55'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:05:06' prior: 50666006!
test02

	| aCustomer |
	
	self importCustomers.
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	
	self assert: 1 equals: aCustomer size.
	
	! !

!testRun: #ImportTest #test02 stamp: 'SF 6/22/2023 21:05:07'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:05:28' prior: 50665828!
importCustomers

	| inputStream newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber.
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber.
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	inputStream close.
	! !

!testRun: #ImportTest #test02 stamp: 'SF 6/22/2023 21:05:32'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 21:05:32'!
PASSED!

!testRun: #ImportTest #test02 stamp: 'SF 6/22/2023 21:05:33'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:06:12' prior: 50666018!
test02

	| aCustomer |
	
	self importCustomers.
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer first.
	
	self assert: 'Pepe' equals: aCustomer name.
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:07:07' prior: 50666072!
test02

	| aCustomer |
	
	self importCustomers.
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer first.
	
	self assert: 'Pepe' equals: aCustomer name.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 'D' equals: aCustomer identificationType.
	
	! !

!testRun: #ImportTest #test02 stamp: 'SF 6/22/2023 21:07:08'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:07:22' prior: 50666084!
test02

	| aCustomer |
	
	self importCustomers.
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer at: 1.
	
	self assert: 'Pepe' equals: aCustomer name.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 'D' equals: aCustomer identificationType.
	
	! !

!testRun: #ImportTest #test02 stamp: 'SF 6/22/2023 21:07:23'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:07:30' prior: 50666102!
test02

	| aCustomer |
	
	self importCustomers.
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	
	self assert: 'Pepe' equals: aCustomer name.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 'D' equals: aCustomer identificationType.
	
	! !

!testRun: #ImportTest #test02 stamp: 'SF 6/22/2023 21:07:31'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:07:53' prior: 50666120!
test02

	| aCustomer |
	
	self importCustomers.
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 'D' equals: aCustomer identificationType.
	
	! !

!testRun: #ImportTest #test02 stamp: 'SF 6/22/2023 21:07:54'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 21:07:55'!
PASSED!

!testRun: #ImportTest #test02 stamp: 'SF 6/22/2023 21:07:56'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:10:18' prior: 50666138!
test02

	| aCustomer |
	
	self importCustomers.
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 'D' equals: aCustomer identificationType.
	self assert: 2 equals: aCustomer addresses size.
	! !

!testRun: #ImportTest #test02 stamp: 'SF 6/22/2023 21:10:19'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 21:10:20'!
PASSED!

!testRun: #ImportTest #test02 stamp: 'SF 6/22/2023 21:10:20'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:10:45' prior: 50666161!
test02

	| aCustomer |
	
	self importCustomers.
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 'D' equals: aCustomer identificationType.
	self assert: 2 equals: aCustomer addresses size.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:14:41'!
test03

	| aCustomer |
	
	self importCustomers.
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	
	self assert: (aCustomer addresses anySatisfy: [ :anAddress |
		anAddress ])
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:15:16' prior: 50666202!
test03

	| aCustomer |
	
	self importCustomers.
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	
	self assert: (aCustomer addresses anySatisfy: [ :anAddress |
		(anAddress province = 'San Martin') and:
		(anAddress)])
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:15:33' prior: 50666213!
test03

	| aCustomer |
	
	self importCustomers.
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	
	self assert: (aCustomer addresses anySatisfy: [ :anAddress |
		(anAddress streetName = 'San Martin') and:
		(anAddress)])
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:16:05' prior: 50666225!
test03

	| aCustomer |
	
	self importCustomers.
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	
	self assert: (aCustomer addresses anySatisfy: [ :anAddress |
		(anAddress streetName = 'San Martin') and:
		(anAddress streetNumber = '3322') and:
		(anAddress)])
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:17:26' prior: 50666237!
test03

	| aCustomer |
	
	self importCustomers.
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	
	self assert: (aCustomer addresses anySatisfy: [ :anAddress |
		(anAddress streetName = 'San Martin') and:
		(anAddress streetNumber = '3322') and:
		(anAddress town = 'Olivos') and:
		(anAddress zipCode = '1636') and:
		(anAddress province = 'BsAs')
		]) 
	! !

!testRun: #ImportTest #test03 stamp: 'SF 6/22/2023 21:17:29'!
ERROR!

!testRun: #ImportTest #test03 stamp: 'SF 6/22/2023 21:17:39'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:18:00' prior: 50666251!
test03

	| aCustomer |
	
	self importCustomers.
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	aCustomer := aCustomer atRandom.
	
	self assert: (aCustomer addresses anySatisfy: [ :anAddress |
		(anAddress streetName = 'San Martin') and:
		(anAddress streetNumber = '3322') and:
		(anAddress town = 'Olivos') and:
		(anAddress zipCode = '1636') and:
		(anAddress province = 'BsAs')
		]) 
	! !

!testRun: #ImportTest #test03 stamp: 'SF 6/22/2023 21:18:01'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:18:18' prior: 50666030!
importCustomers

	| inputStream newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber.
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber.
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:18:29' prior: 50666272!
test03

	| aCustomer |
	
	self importCustomers.
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	aCustomer := aCustomer atRandom.
	
	self assert: (aCustomer addresses anySatisfy: [ :anAddress |
		(anAddress streetName = 'San Martin') and:
		(anAddress streetNumber = 3322) and:
		(anAddress town = 'Olivos') and:
		(anAddress zipCode = 1636) and:
		(anAddress province = 'BsAs')
		]) 
	! !

!testRun: #ImportTest #test03 stamp: 'SF 6/22/2023 21:18:30'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 21:18:31'!
PASSED!

!testRun: #ImportTest #test02 stamp: 'SF 6/22/2023 21:18:32'!
PASSED!

!testRun: #ImportTest #test03 stamp: 'SF 6/22/2023 21:18:32'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:20:07' prior: 50665985!
test01Import

	| aCustomer |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:20:20' prior: 50666354!
test01Import

	| aCustomer |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:20:29' prior: 50666365!
test01Import

	| aCustomer |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	self assert: 1 equals: aCustomer size.! !

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 21:20:31'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 21:20:32'!
PASSED!

!testRun: #ImportTest #test02 stamp: 'SF 6/22/2023 21:20:33'!
PASSED!

!testRun: #ImportTest #test03 stamp: 'SF 6/22/2023 21:20:33'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:20:58' prior: 50666379!
test01Import

	| aCustomer |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 'D' equals: aCustomer identificationType.
	self assert: 2 equals: aCustomer addresses size.! !

!methodRemoval: ImportTest #test02 stamp: 'SF 6/22/2023 21:21:03'!
test02

	| aCustomer |
	
	self importCustomers.
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 'D' equals: aCustomer identificationType.
	self assert: 2 equals: aCustomer addresses size.
	!

!methodRemoval: ImportTest #test03 stamp: 'SF 6/22/2023 21:21:13'!
test03

	| aCustomer |
	
	self importCustomers.
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	aCustomer := aCustomer atRandom.
	
	self assert: (aCustomer addresses anySatisfy: [ :anAddress |
		(anAddress streetName = 'San Martin') and:
		(anAddress streetNumber = 3322) and:
		(anAddress town = 'Olivos') and:
		(anAddress zipCode = 1636) and:
		(anAddress province = 'BsAs')
		]) 
	!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:21:18' prior: 50666404!
test01Import

	| aCustomer |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 'D' equals: aCustomer identificationType.
	self assert: 2 equals: aCustomer addresses size.
	
	self assert: (aCustomer addresses anySatisfy: [ :anAddress |
		(anAddress streetName = 'San Martin') and:
		(anAddress streetNumber = 3322) and:
		(anAddress town = 'Olivos') and:
		(anAddress zipCode = 1636) and:
		(anAddress province = 'BsAs')
		]) ! !

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 21:21:20'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 21:21:21'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:21:39' prior: 50666459!
test01Import

	| aCustomer |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 'D' equals: aCustomer identificationType.
	self assert: 2 equals: aCustomer addresses size.
	
	self assert: (aCustomer addresses anySatisfy: [ :anAddress |
		(anAddress streetName = 'San Martin') and:
		(anAddress streetNumber = 3322) and:
		(anAddress town = 'Olivos') and:
		(anAddress zipCode = 1636) and:
		(anAddress province = 'BsAs')
		]) ! !
!Customer methodsFor: 'addresses' stamp: 'SF 6/22/2023 21:36:50'!
addressesAtStreet: streetName

	^ addresses select: [ :anAddress | anAddress streetName = streetName ]! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:39:31' prior: 50666495!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 'D' equals: aCustomer identificationType.
	self assert: 2 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	! !

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 21:39:37'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 21:39:38'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:40:28' prior: 50666532!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	aCustomer := session select: [ :customer | customer identificationNumber = '22333444' ] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 'D' equals: aCustomer identificationType.
	self assert: 2 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	! !

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 21:40:30'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 21:40:30'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:41:38' prior: 50666570!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'D' and: customer identificationNumber = '22333444'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 'D' equals: aCustomer identificationType.
	self assert: 2 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	! !

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 21:41:40'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 21:41:41'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:42:34' prior: 50666618!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'D' and:
		customer identificationNumber = '22333444'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 'D' equals: aCustomer identificationType.
	self assert: 2 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:42:45' prior: 50666668!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'D' and:
		customer identificationNumber = '22333444'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 2 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:43:13' prior: 50666719!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'D' and:
		customer identificationNumber = '22333444'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 2 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.! !

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 21:43:15'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 21:43:16'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SF 6/22/2023 21:43:55' prior: 50666768!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'D' and:
		customer identificationNumber = '22333444'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 2 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 21:43:57'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SF 6/22/2023 21:43:58'!
PASSED!
!Customer methodsFor: 'name' stamp: 'SF 6/22/2023 21:46:10' prior: 50665122!
firstName

	^ firstName ! !

----STARTUP---- (25 June 2023 15:09:29) as C:\Users\Santii\Desktop\UBA\inge1\windows64\CuisUniversity-5832.image!


----End fileIn of C:\Users\Santii\Desktop\UBA\inge1\windows64\CustomerImporter.st----!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:12:10' prior: 50624416!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
		
	aCustomer := session select: [ :customer |
		customer identificationType = 'D' and:
		customer identificationNumber = '22333444'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 2 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:13:24' prior: 50624712!
test01Import

	| aCustomer anAddress |
	aCustomer := session select: [ :customer |
		customer identificationType = 'D' and:
		customer identificationNumber = '22333444'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'D' and:
		customer identificationNumber = '22333444'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 2 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:15:03' prior: 50624779!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	session select: [ :customer |
		customer identificationType = 'D' and:
		customer identificationNumber = '22333444'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 2 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:17:03'!
m1

	^ session select: [ :customer |
		customer identificationType = 'D' and:
		customer identificationNumber = '22333444'
		] ofType: Customer! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:17:03' prior: 50624852!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self m1.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 2 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:17:21'!
m1: idType

	^ session select: [ :customer |
		customer identificationType = 'D' and:
		customer identificationNumber = '22333444'
		] ofType: Customer! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:17:21' prior: 50624926!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self m1: 'D'.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 2 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !

!methodRemoval: ImportTest #m1 stamp: 'sdf 6/25/2023 15:17:21'!
m1

	^ session select: [ :customer |
		customer identificationType = 'D' and:
		customer identificationNumber = '22333444'
		] ofType: Customer!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:17:21' prior: 50624988!
m1: idType

	^ session select: [ :customer |
		customer identificationType = idType and:
		customer identificationNumber = '22333444'
		] ofType: Customer! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:18:04'!
m1: idType a: idNumber 

	^ session select: [ :customer |
		customer identificationType = idType and:
		customer identificationNumber = '22333444'
		] ofType: Customer! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:18:04' prior: 50624996!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self m1: 'D' a: '22333444'.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 2 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !

!methodRemoval: ImportTest #m1: stamp: 'sdf 6/25/2023 15:18:04'!
m1: idType

	^ session select: [ :customer |
		customer identificationType = idType and:
		customer identificationNumber = '22333444'
		] ofType: Customer!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:18:04' prior: 50625073!
m1: idType a: idNumber 

	^ session select: [ :customer |
		customer identificationType = idType and:
		customer identificationNumber = idNumber
		] ofType: Customer! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:18:27' prior: 50625082!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self m1: 'D' a: '22333444'.
	aCustomer := aCustomer atRandom.
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 2 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:19:18' prior: 50625152!
m1: idType a: idNumber 

	| aCustomer |
	
	aCustomer := session select: [ :customer |
		customer identificationType = idType and:
		customer identificationNumber = idNumber
		] ofType: Customer.
	
	^ aCustomer size = 1.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:20:30'!
thereIsExactlyOneCustomerWithIDType: idType andIDNumber: idNumber 

	| aCustomer |
	
	aCustomer := session select: [ :customer |
		customer identificationType = idType and:
		customer identificationNumber = idNumber
		] ofType: Customer.
	
	^ aCustomer size = 1.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:20:30' prior: 50625161!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self thereIsExactlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	aCustomer := aCustomer atRandom.
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 2 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !

!methodRemoval: ImportTest #m1:a: stamp: 'sdf 6/25/2023 15:20:30'!
m1: idType a: idNumber 

	| aCustomer |
	
	aCustomer := session select: [ :customer |
		customer identificationType = idType and:
		customer identificationNumber = idNumber
		] ofType: Customer.
	
	^ aCustomer size = 1.!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:21:33' prior: 50625233!
thereIsExactlyOneCustomerWithIDType: idType andIDNumber: idNumber 

	| aCustomer |
	
	aCustomer := session select: [ :customer |
		customer identificationType = idType and:
		customer identificationNumber = idNumber
		] ofType: Customer.
	
	^aCustomer.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:21:45'!
customersWithIDType: idType andIDNumber: idNumber 

	| aCustomer |
	
	aCustomer := session select: [ :customer |
		customer identificationType = idType and:
		customer identificationNumber = idNumber
		] ofType: Customer.
	
	^aCustomer.! !

!methodRemoval: ImportTest #thereIsExactlyOneCustomerWithIDType:andIDNumber: stamp: 'sdf 6/25/2023 15:21:47'!
thereIsExactlyOneCustomerWithIDType: idType andIDNumber: idNumber 

	| aCustomer |
	
	aCustomer := session select: [ :customer |
		customer identificationType = idType and:
		customer identificationNumber = idNumber
		] ofType: Customer.
	
	^aCustomer.!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:23:42' prior: 50625245!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	aCustomer := self customersWithIDType: 'D' andIDNumber: '22333444'.
	
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 2 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:23:50'!
m1: aCustomer

	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 2 equals: aCustomer addresses size! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:23:50' prior: 50625351!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	aCustomer := self customersWithIDType: 'D' andIDNumber: '22333444'.
	
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self m1: aCustomer.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:24:20'!
m1: aCustomer name: customerName 

	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 2 equals: aCustomer addresses size! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:24:20' prior: 50625424!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	aCustomer := self customersWithIDType: 'D' andIDNumber: '22333444'.
	
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self m1: aCustomer name: 'Pepe'.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !

!methodRemoval: ImportTest #m1: stamp: 'sdf 6/25/2023 15:24:20'!
m1: aCustomer

	self assert: 'Pepe' equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 2 equals: aCustomer addresses size!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:24:20' prior: 50625484!
m1: aCustomer name: customerName 

	self assert: customerName equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 2 equals: aCustomer addresses size! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:24:40'!
m1: aCustomer name: customerName lastName: customerLastName  

	self assert: customerName equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 2 equals: aCustomer addresses size! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:24:40' prior: 50625493!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	aCustomer := self customersWithIDType: 'D' andIDNumber: '22333444'.
	
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self m1: aCustomer name: 'Pepe' lastName: 'Sanchez'.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !

!methodRemoval: ImportTest #m1:name: stamp: 'sdf 6/25/2023 15:24:40'!
m1: aCustomer name: customerName 

	self assert: customerName equals: aCustomer firstName.
	self assert: 'Sanchez' equals: aCustomer lastName.
	self assert: 2 equals: aCustomer addresses size!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:24:40' prior: 50625570!
m1: aCustomer name: customerName lastName: customerLastName  

	self assert: customerName equals: aCustomer firstName.
	self assert: customerLastName equals: aCustomer lastName.
	self assert: 2 equals: aCustomer addresses size! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:25:11'!
m1: aCustomer name: customerName lastName: customerLastName amountOfAddresses: amountOfAddresses   

	self assert: customerName equals: aCustomer firstName.
	self assert: customerLastName equals: aCustomer lastName.
	self assert: 2 equals: aCustomer addresses size! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:25:11' prior: 50625580!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	aCustomer := self customersWithIDType: 'D' andIDNumber: '22333444'.
	
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self m1: aCustomer name: 'Pepe' lastName: 'Sanchez' amountOfAddresses: 2.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !

!methodRemoval: ImportTest #m1:name:lastName: stamp: 'sdf 6/25/2023 15:25:11'!
m1: aCustomer name: customerName lastName: customerLastName  

	self assert: customerName equals: aCustomer firstName.
	self assert: customerLastName equals: aCustomer lastName.
	self assert: 2 equals: aCustomer addresses size!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:25:11' prior: 50625659!
m1: aCustomer name: customerName lastName: customerLastName amountOfAddresses: amountOfAddresses   

	self assert: customerName equals: aCustomer firstName.
	self assert: customerLastName equals: aCustomer lastName.
	self assert: amountOfAddresses equals: aCustomer addresses size! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:28:24'!
assertCustomer: aCustomer hasFirstName: customerName andLastName: customerLastName andAmountOfAddresses: amountOfAddresses   

	self assert: customerName equals: aCustomer firstName.
	self assert: customerLastName equals: aCustomer lastName.
	self assert: amountOfAddresses equals: aCustomer addresses size! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:28:24' prior: 50625671!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	aCustomer := self customersWithIDType: 'D' andIDNumber: '22333444'.
	
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !

!methodRemoval: ImportTest #m1:name:lastName:amountOfAddresses: stamp: 'sdf 6/25/2023 15:28:24'!
m1: aCustomer name: customerName lastName: customerLastName amountOfAddresses: amountOfAddresses   

	self assert: customerName equals: aCustomer firstName.
	self assert: customerLastName equals: aCustomer lastName.
	self assert: amountOfAddresses equals: aCustomer addresses size!

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 15:28:46'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 15:28:47'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:30:45' prior: 50625328!
customersWithIDType: idType andIDNumber: idNumber 

	| aCustomer |
	
	aCustomer := session select: [ :customer |
		customer identificationType = idType and:
		customer identificationNumber = idNumber
		] ofType: Customer.
	
	self assert: 1 equals: aCustomer size.
	
	^aCustomer! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:32:53' prior: 50625767!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customersWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:33:27'!
assertThereIsOnlyOneCustomerWithIDType: idType andIDNumber: idNumber

	| aCustomer |
	
	aCustomer := session select: [ :customer |
		customer identificationType = idType and:
		customer identificationNumber = idNumber
		] ofType: Customer.
	
	self assert: 1 equals: aCustomer size.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:33:42'!
customerWithIDType: idType andIDNumber: idNumber 

	| aCustomer |
	
	aCustomer := session select: [ :customer |
		customer identificationType = idType and:
		customer identificationNumber = idNumber
		] ofType: Customer.
	
	self assert: 1 equals: aCustomer size.
	
	^aCustomer! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:33:42' prior: 50625858!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !

!methodRemoval: ImportTest #customersWithIDType:andIDNumber: stamp: 'sdf 6/25/2023 15:33:42'!
customersWithIDType: idType andIDNumber: idNumber 

	| aCustomer |
	
	aCustomer := session select: [ :customer |
		customer identificationType = idType and:
		customer identificationNumber = idNumber
		] ofType: Customer.
	
	self assert: 1 equals: aCustomer size.
	
	^aCustomer!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:33:50' prior: 50625932!
customerWithIDType: idType andIDNumber: idNumber 

	| aCustomer |
	
	aCustomer := session select: [ :customer |
		customer identificationType = idType and:
		customer identificationNumber = idNumber
		] ofType: Customer.
	
	^aCustomer atRandom.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:34:46' prior: 50625920!
assertThereIsOnlyOneCustomerWithIDType: idType andIDNumber: idNumber

	| aCustomer |
	
	aCustomer := session select: [ :customer |
		customer identificationType = idType and:
		customer identificationNumber = idNumber
		] ofType: Customer.
	
	"self assert: 1 equals: aCustomer size."! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:37:10'!
selectCustomersWithIDType: idType andIDNumber: idNumber

	| aCustomer |
	
	aCustomer := session select: [ :customer |
		customer identificationType = idType and:
		customer identificationNumber = idNumber
		] ofType: Customer! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:37:10' prior: 50626029!
assertThereIsOnlyOneCustomerWithIDType: idType andIDNumber: idNumber

	self selectCustomersWithIDType: idType andIDNumber: idNumber.
	
	"self assert: 1 equals: aCustomer size."! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:37:31' prior: 50626052!
assertThereIsOnlyOneCustomerWithIDType: idType andIDNumber: idNumber

	| customers |

	customers := self selectCustomersWithIDType: idType andIDNumber: idNumber.
	
	self assert: 1 equals: customers size.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:37:52' prior: 50626018!
customerWithIDType: idType andIDNumber: idNumber 

	| customers |

	customers := self selectCustomersWithIDType: idType andIDNumber: idNumber.
	
	^customers atRandom.! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 15:38:05'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:38:34' prior: 50626041!
selectCustomersWithIDType: idType andIDNumber: idNumber

	^ session select: [ :customer |
		customer identificationType = idType and:
		customer identificationNumber = idNumber
		] ofType: Customer! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 15:38:38'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:40:57' prior: 50625944!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:41:05'!
m1: anAddress

	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:41:05' prior: 50626094!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self assert: 1 equals: anAddress size.
	anAddress := anAddress first.
	self m1: anAddress.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:42:48' prior: 50626166!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	anAddress := anAddress first.
	self m1: anAddress.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:43:10' prior: 50626156!
m1: anAddress

	self assert: 'San Martin' equals: anAddress streetName.

	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:44:38'!
m1: anAddress a: streetName 

	self assert: 'San Martin' equals: anAddress streetName.

	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:44:38' prior: 50626223!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	anAddress := anAddress first.
	self m1: anAddress a: 'San Martin'.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !

!methodRemoval: ImportTest #m1: stamp: 'sdf 6/25/2023 15:44:38'!
m1: anAddress

	self assert: 'San Martin' equals: anAddress streetName.

	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:44:38' prior: 50626290!
m1: anAddress a: streetName 

	self assert: streetName equals: anAddress streetName.

	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:44:51'!
m1: anAddress a: streetName b: streetNumber  

	self assert: streetName equals: anAddress streetName.

	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:44:51' prior: 50626302!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	anAddress := anAddress first.
	self m1: anAddress a: 'San Martin' b: 3322.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !

!methodRemoval: ImportTest #m1:a: stamp: 'sdf 6/25/2023 15:44:51'!
m1: anAddress a: streetName 

	self assert: streetName equals: anAddress streetName.

	self assert: 3322 equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:44:51' prior: 50626381!
m1: anAddress a: streetName b: streetNumber  

	self assert: streetName equals: anAddress streetName.

	self assert: streetNumber equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:45:03'!
m1: anAddress a: streetName b: streetNumber c: town   

	self assert: streetName equals: anAddress streetName.

	self assert: streetNumber equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:45:03' prior: 50626394!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	anAddress := anAddress first.
	self m1: anAddress a: 'San Martin' b: 3322 c: 'Olivos'.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !

!methodRemoval: ImportTest #m1:a:b: stamp: 'sdf 6/25/2023 15:45:03'!
m1: anAddress a: streetName b: streetNumber  

	self assert: streetName equals: anAddress streetName.

	self assert: streetNumber equals: anAddress streetNumber.
	self assert: 'Olivos' equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:45:03' prior: 50626474!
m1: anAddress a: streetName b: streetNumber c: town   

	self assert: streetName equals: anAddress streetName.

	self assert: streetNumber equals: anAddress streetNumber.
	self assert: town equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:45:22'!
m1: anAddress a: streetName b: streetNumber c: town d: zipCode    

	self assert: streetName equals: anAddress streetName.

	self assert: streetNumber equals: anAddress streetNumber.
	self assert: town equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:45:22' prior: 50626487!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	anAddress := anAddress first.
	self m1: anAddress a: 'San Martin' b: 3322 c: 'Olivos' d: 1636.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !

!methodRemoval: ImportTest #m1:a:b:c: stamp: 'sdf 6/25/2023 15:45:22'!
m1: anAddress a: streetName b: streetNumber c: town   

	self assert: streetName equals: anAddress streetName.

	self assert: streetNumber equals: anAddress streetNumber.
	self assert: town equals: anAddress town.
	self assert: 1636 equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:45:22' prior: 50626569!
m1: anAddress a: streetName b: streetNumber c: town d: zipCode    

	self assert: streetName equals: anAddress streetName.

	self assert: streetNumber equals: anAddress streetNumber.
	self assert: town equals: anAddress town.
	self assert: zipCode equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:45:39'!
m1: anAddress a: streetName b: streetNumber c: town d: zipCode e: province     

	self assert: streetName equals: anAddress streetName.

	self assert: streetNumber equals: anAddress streetNumber.
	self assert: town equals: anAddress town.
	self assert: zipCode equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:45:39' prior: 50626583!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	anAddress := anAddress first.
	self m1: anAddress a: 'San Martin' b: 3322 c: 'Olivos' d: 1636 e: 'BsAs'.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !

!methodRemoval: ImportTest #m1:a:b:c:d: stamp: 'sdf 6/25/2023 15:45:39'!
m1: anAddress a: streetName b: streetNumber c: town d: zipCode    

	self assert: streetName equals: anAddress streetName.

	self assert: streetNumber equals: anAddress streetNumber.
	self assert: town equals: anAddress town.
	self assert: zipCode equals: anAddress zipCode.
	self assert: 'BsAs' equals: anAddress province!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:45:39' prior: 50626665!
m1: anAddress a: streetName b: streetNumber c: town d: zipCode e: province     

	self assert: streetName equals: anAddress streetName.

	self assert: streetNumber equals: anAddress streetNumber.
	self assert: town equals: anAddress town.
	self assert: zipCode equals: anAddress zipCode.
	self assert: province equals: anAddress province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:46:26' prior: 50626679!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	anAddress := aCustomer addressesAtStreet: 'San Martin'.
	self m1: aCustomer a: 'San Martin' b: 3322 c: 'Olivos' d: 1636 e: 'BsAs'.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:46:31' prior: 50626763!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	self m1: aCustomer a: 'San Martin' b: 3322 c: 'Olivos' d: 1636 e: 'BsAs'.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:49:01' prior: 50626749!
m1: aCustomer a: streetName b: streetNumber c: town d: zipCode e: province

	| addresses |

	addresses := aCustomer addressesAtStreet: 'San Martin'.
	
	self assert: (addresses anySatisfy: [ :anAddress |
		(streetNumber = anAddress streetNumber) and:
		(town = anAddress town) and:
		(zipCode = anAddress zipCode) and:
		(province = anAddress province)
	]).! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 15:49:17'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 15:49:18'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:50:34'!
assertCustomer: aCustomer hasAddressAtStreet: streetName atNumber: streetNumber atTown: town withZipCode: zipCode atProvince: province

	| addresses |

	addresses := aCustomer addressesAtStreet: 'San Martin'.
	
	self assert: (addresses anySatisfy: [ :anAddress |
		(streetNumber = anAddress streetNumber) and:
		(town = anAddress town) and:
		(zipCode = anAddress zipCode) and:
		(province = anAddress province)
	]).! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:50:34' prior: 50626819!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	self assertCustomer: aCustomer hasAddressAtStreet: 'San Martin' atNumber: 3322 atTown: 'Olivos' withZipCode: 1636 atProvince: 'BsAs'.	
	
	anAddress := aCustomer addressesAtStreet: 'Maipu'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 888 equals: anAddress streetNumber.
	self assert: 'Florida' equals: anAddress town.
	self assert: 1122 equals: anAddress zipCode.
	self assert: 'Buenos Aires' equals: anAddress province.	
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !

!methodRemoval: ImportTest #m1:a:b:c:d:e: stamp: 'sdf 6/25/2023 15:50:34'!
m1: aCustomer a: streetName b: streetNumber c: town d: zipCode e: province

	| addresses |

	addresses := aCustomer addressesAtStreet: 'San Martin'.
	
	self assert: (addresses anySatisfy: [ :anAddress |
		(streetNumber = anAddress streetNumber) and:
		(town = anAddress town) and:
		(zipCode = anAddress zipCode) and:
		(province = anAddress province)
	]).!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:51:46' prior: 50626910!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	self assertCustomer: aCustomer hasAddressAtStreet: 'San Martin' atNumber: 3322 atTown: 'Olivos' withZipCode: 1636 atProvince: 'BsAs'.	
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Maipu' atNumber: 888 atTown: 'Florida' withZipCode: 1122 atProvince: 'Buenos Aires'.
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 15:51:48'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:52:23' prior: 50626893!
assertCustomer: aCustomer hasAddressAtStreet: streetName atNumber: streetNumber atTown: town withZipCode: zipCode atProvince: province

	| addresses |

	addresses := aCustomer addressesAtStreet: streetName.
	
	self assert: (addresses anySatisfy: [ :anAddress |
		(streetNumber = anAddress streetNumber) and:
		(town = anAddress town) and:
		(zipCode = anAddress zipCode) and:
		(province = anAddress province)
	]).! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 15:52:27'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:52:36' prior: 50626980!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	self assertCustomer: aCustomer hasAddressAtStreet: 'San Martin' atNumber: 3322 atTown: 'Olivos' withZipCode: 1636 atProvince: 'BsAs'.	
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Maipu' atNumber: 888 atTown: 'Florida' withZipCode: 1122 atProvince: 'Buenos Aires'.
	
	aCustomer := session select: [ :customer |
		customer identificationType = 'C' and:
		customer identificationNumber = '23-25666777-9'
		] ofType: Customer.
	self assert: 1 equals: aCustomer size.
	
	aCustomer := aCustomer atRandom.
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:53:10' prior: 50627052!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	self assertCustomer: aCustomer hasAddressAtStreet: 'San Martin' atNumber: 3322 atTown: 'Olivos' withZipCode: 1636 atProvince: 'BsAs'.	
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Maipu' atNumber: 888 atTown: 'Florida' withZipCode: 1122 atProvince: 'Buenos Aires'.
	
	self assertThereIsOnlyOneCustomerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 15:53:12'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:53:41' prior: 50627102!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	self assertCustomer: aCustomer hasAddressAtStreet: 'San Martin' atNumber: 3322 atTown: 'Olivos' withZipCode: 1636 atProvince: 'BsAs'.	
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Maipu' atNumber: 888 atTown: 'Florida' withZipCode: 1122 atProvince: 'Buenos Aires'.
	
	self assertThereIsOnlyOneCustomerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	aCustomer := self customerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	self assert: 'Juan' equals: aCustomer firstName.
	self assert: 'Perez' equals: aCustomer lastName.
	self assert: 1 equals: aCustomer addresses size.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 15:53:42'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 15:53:43'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:54:24' prior: 50627152!
test01Import

	| aCustomer anAddress |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	self assertCustomer: aCustomer hasAddressAtStreet: 'San Martin' atNumber: 3322 atTown: 'Olivos' withZipCode: 1636 atProvince: 'BsAs'.	
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Maipu' atNumber: 888 atTown: 'Florida' withZipCode: 1122 atProvince: 'Buenos Aires'.
	
	self assertThereIsOnlyOneCustomerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	aCustomer := self customerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	self assertCustomer: aCustomer hasFirstName: 'Juan' andLastName: 'Perez' andAmountOfAddresses: 1.
	
	anAddress := aCustomer addressesAtStreet: 'Alem'.
	self assert: 1 equals: anAddress size.
	
	anAddress := anAddress first.
	self assert: 1122 equals: anAddress streetNumber.
	self assert: 'CABA' equals: anAddress town.
	self assert: 1001 equals: anAddress zipCode.
	self assert: 'CABA' equals: anAddress province.	! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 15:54:25'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 15:54:27'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:55:11' prior: 50627204!
test01Import

	| aCustomer |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	self assertCustomer: aCustomer hasAddressAtStreet: 'San Martin' atNumber: 3322 atTown: 'Olivos' withZipCode: 1636 atProvince: 'BsAs'.	
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Maipu' atNumber: 888 atTown: 'Florida' withZipCode: 1122 atProvince: 'Buenos Aires'.
	
	self assertThereIsOnlyOneCustomerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	aCustomer := self customerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	self assertCustomer: aCustomer hasFirstName: 'Juan' andLastName: 'Perez' andAmountOfAddresses: 1.
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Alem' atNumber: 1122 atTown: 'CABA' withZipCode: 1001 atProvince: 'CABA'.! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 15:55:16'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 15:55:17'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:55:28' prior: 50627255!
test01Import

	| aCustomer |

	self importCustomers.
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	self assertCustomer: aCustomer hasAddressAtStreet: 'San Martin' atNumber: 3322 atTown: 'Olivos' withZipCode: 1636 atProvince: 'BsAs'.	
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Maipu' atNumber: 888 atTown: 'Florida' withZipCode: 1122 atProvince: 'Buenos Aires'.
	
	self assertThereIsOnlyOneCustomerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	aCustomer := self customerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	self assertCustomer: aCustomer hasFirstName: 'Juan' andLastName: 'Perez' andAmountOfAddresses: 1.
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Alem' atNumber: 1122 atTown: 'CABA' withZipCode: 1001 atProvince: 'CABA'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:55:47'!
m1

	^ self assert: 2 equals: (session selectAllOfType: Customer) size! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:55:47' prior: 50627299!
test01Import

	| aCustomer |

	self importCustomers.
	self m1.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	self assertCustomer: aCustomer hasAddressAtStreet: 'San Martin' atNumber: 3322 atTown: 'Olivos' withZipCode: 1636 atProvince: 'BsAs'.	
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Maipu' atNumber: 888 atTown: 'Florida' withZipCode: 1122 atProvince: 'Buenos Aires'.
	
	self assertThereIsOnlyOneCustomerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	aCustomer := self customerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	self assertCustomer: aCustomer hasFirstName: 'Juan' andLastName: 'Perez' andAmountOfAddresses: 1.
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Alem' atNumber: 1122 atTown: 'CABA' withZipCode: 1001 atProvince: 'CABA'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:56:10'!
m1: amountOfCustomers

	^ self assert: 2 equals: (session selectAllOfType: Customer) size! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:56:11' prior: 50627344!
test01Import

	| aCustomer |

	self importCustomers.
	self m1: 2.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	self assertCustomer: aCustomer hasAddressAtStreet: 'San Martin' atNumber: 3322 atTown: 'Olivos' withZipCode: 1636 atProvince: 'BsAs'.	
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Maipu' atNumber: 888 atTown: 'Florida' withZipCode: 1122 atProvince: 'Buenos Aires'.
	
	self assertThereIsOnlyOneCustomerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	aCustomer := self customerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	self assertCustomer: aCustomer hasFirstName: 'Juan' andLastName: 'Perez' andAmountOfAddresses: 1.
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Alem' atNumber: 1122 atTown: 'CABA' withZipCode: 1001 atProvince: 'CABA'.! !

!methodRemoval: ImportTest #m1 stamp: 'sdf 6/25/2023 15:56:11'!
m1

	^ self assert: 2 equals: (session selectAllOfType: Customer) size!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:56:11' prior: 50627381!
m1: amountOfCustomers

	^ self assert: amountOfCustomers equals: (session selectAllOfType: Customer) size! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:56:39'!
assertAmountOfCustomersIs: amountOfCustomers

	^ self assert: amountOfCustomers equals: (session selectAllOfType: Customer) size! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:56:39' prior: 50627387!
test01Import

	| aCustomer |

	self importCustomers.
	self assertAmountOfCustomersIs: 2.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ] ).
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	self assertCustomer: aCustomer hasAddressAtStreet: 'San Martin' atNumber: 3322 atTown: 'Olivos' withZipCode: 1636 atProvince: 'BsAs'.	
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Maipu' atNumber: 888 atTown: 'Florida' withZipCode: 1122 atProvince: 'Buenos Aires'.
	
	self assertThereIsOnlyOneCustomerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	aCustomer := self customerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	self assertCustomer: aCustomer hasFirstName: 'Juan' andLastName: 'Perez' andAmountOfAddresses: 1.
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Alem' atNumber: 1122 atTown: 'CABA' withZipCode: 1001 atProvince: 'CABA'.! !

!methodRemoval: ImportTest #m1: stamp: 'sdf 6/25/2023 15:56:39'!
m1: amountOfCustomers

	^ self assert: amountOfCustomers equals: (session selectAllOfType: Customer) size!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:56:59' prior: 50627443!
test01Import

	| aCustomer |

	self importCustomers.
	self assertAmountOfCustomersIs: 2.
	self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ]).
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	self assertCustomer: aCustomer hasAddressAtStreet: 'San Martin' atNumber: 3322 atTown: 'Olivos' withZipCode: 1636 atProvince: 'BsAs'.	
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Maipu' atNumber: 888 atTown: 'Florida' withZipCode: 1122 atProvince: 'Buenos Aires'.
	
	self assertThereIsOnlyOneCustomerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	aCustomer := self customerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	self assertCustomer: aCustomer hasFirstName: 'Juan' andLastName: 'Perez' andAmountOfAddresses: 1.
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Alem' atNumber: 1122 atTown: 'CABA' withZipCode: 1001 atProvince: 'CABA'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:57:11'!
assertAmountOfAddressesIs

	^ self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ])! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:57:11' prior: 50627487!
test01Import

	| aCustomer |

	self importCustomers.
	self assertAmountOfCustomersIs: 2.
	self assertAmountOfAddressesIs.
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	self assertCustomer: aCustomer hasAddressAtStreet: 'San Martin' atNumber: 3322 atTown: 'Olivos' withZipCode: 1636 atProvince: 'BsAs'.	
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Maipu' atNumber: 888 atTown: 'Florida' withZipCode: 1122 atProvince: 'Buenos Aires'.
	
	self assertThereIsOnlyOneCustomerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	aCustomer := self customerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	self assertCustomer: aCustomer hasFirstName: 'Juan' andLastName: 'Perez' andAmountOfAddresses: 1.
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Alem' atNumber: 1122 atTown: 'CABA' withZipCode: 1001 atProvince: 'CABA'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:57:36'!
assertAmountOfAddressesIs: amountOfAddresses

	^ self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ])! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:57:36' prior: 50627533!
test01Import

	| aCustomer |

	self importCustomers.
	self assertAmountOfCustomersIs: 2.
	self assertAmountOfAddressesIs: 3.
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	self assertCustomer: aCustomer hasAddressAtStreet: 'San Martin' atNumber: 3322 atTown: 'Olivos' withZipCode: 1636 atProvince: 'BsAs'.	
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Maipu' atNumber: 888 atTown: 'Florida' withZipCode: 1122 atProvince: 'Buenos Aires'.
	
	self assertThereIsOnlyOneCustomerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	aCustomer := self customerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	self assertCustomer: aCustomer hasFirstName: 'Juan' andLastName: 'Perez' andAmountOfAddresses: 1.
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Alem' atNumber: 1122 atTown: 'CABA' withZipCode: 1001 atProvince: 'CABA'.! !

!methodRemoval: ImportTest #assertAmountOfAddressesIs stamp: 'sdf 6/25/2023 15:57:36'!
assertAmountOfAddressesIs

	^ self assert: 3 equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ])!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:57:36' prior: 50627569!
assertAmountOfAddressesIs: amountOfAddresses

	^ self assert: amountOfAddresses equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ])! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 15:59:39'!
pepe

	| aCustomer |
	
	aCustomer := Customer new.
		! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:01:41' prior: 50627628!
pepe

	| aCustomer |
	
	aCustomer := Customer new.
	aCustomer firstName: 'Pepe'.
	aCustomer lastName: 'Sanchez'.
	aCustomer identificationType: 'D'.
	aCustomer identificationNumber: ''
		! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:02:35' prior: 50627633!
pepe

	| aCustomer firstAddress secondAddress |
	
	aCustomer := Customer new.
	aCustomer firstName: 'Pepe'.
	aCustomer lastName: 'Sanchez'.
	aCustomer identificationType: 'D'.
	aCustomer identificationNumber: '22333444'.
	
	firstAddress := Address new.
	
		! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:02:43' prior: 50627642!
pepe

	| aCustomer firstAddress |
	
	aCustomer := Customer new.
	aCustomer firstName: 'Pepe'.
	aCustomer lastName: 'Sanchez'.
	aCustomer identificationType: 'D'.
	aCustomer identificationNumber: '22333444'.
	
	firstAddress := Address new.
	
	^ aCustomer.
		! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:06:29' prior: 50627577!
test01Import

	| aCustomer |

	self importCustomers.
	self assertAmountOfCustomersIs: 2.
	self assertAmountOfAddressesIs: 3.
	
	self assert: (self m1: self pepe).
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	self assertCustomer: aCustomer hasAddressAtStreet: 'San Martin' atNumber: 3322 atTown: 'Olivos' withZipCode: 1636 atProvince: 'BsAs'.	
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Maipu' atNumber: 888 atTown: 'Florida' withZipCode: 1122 atProvince: 'Buenos Aires'.
	
	self assertThereIsOnlyOneCustomerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	aCustomer := self customerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	self assertCustomer: aCustomer hasFirstName: 'Juan' andLastName: 'Perez' andAmountOfAddresses: 1.
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Alem' atNumber: 1122 atTown: 'CABA' withZipCode: 1001 atProvince: 'CABA'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:08:51' prior: 50627654!
pepe

	| aCustomer firstAddress secondAddress |
	
	aCustomer := Customer new.
	aCustomer firstName: 'Pepe'.
	aCustomer lastName: 'Sanchez'.
	aCustomer identificationType: 'D'.
	aCustomer identificationNumber: '22333444'.
	
	firstAddress := Address new.
	firstAddress streetName: 'San Martin'.
	firstAddress streetNumber: 3322.
	firstAddress town: 'Olivos'.
	firstAddress zipCode: 1636.
	firstAddress province: 'BsAs'.
	
	secondAddress := Address new.
	secondAddress streetName: 'Maipu'.
	secondAddress streetNumber: 888.
	secondAddress town: 'Florida'.
	secondAddress zipCode: 1122.
	secondAddress province: 'Buenos Aires'.
	
	aCustomer addAddress: firstAddress.
	aCustomer addAddress: secondAddress.
	
	^ aCustomer.
		! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:09:32'!
m1: aCustomer

	self assertCustomer: aCustomer hasFirstName: 'Pepe' andLastName: 'Sanchez' andAmountOfAddresses: 2.
	self assertCustomer: aCustomer hasAddressAtStreet: 'San Martin' atNumber: 3322 atTown: 'Olivos' withZipCode: 1636 atProvince: 'BsAs'.	
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Maipu' atNumber: 888 atTown: 'Florida' withZipCode: 1122 atProvince: 'Buenos Aires'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:09:32' prior: 50627666!
test01Import

	| aCustomer |

	self importCustomers.
	self assertAmountOfCustomersIs: 2.
	self assertAmountOfAddressesIs: 3.
	
	self assert: (self m1: self pepe).
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self m1: aCustomer.
	
	self assertThereIsOnlyOneCustomerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	aCustomer := self customerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	self assertCustomer: aCustomer hasFirstName: 'Juan' andLastName: 'Perez' andAmountOfAddresses: 1.
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Alem' atNumber: 1122 atTown: 'CABA' withZipCode: 1001 atProvince: 'CABA'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:12:14' prior: 50627729!
m1: aCustomer

	| customerInDB |

	self assertThereIsOnlyOneCustomerWithIDType: aCustomer identificationType andIDNumber: aCustomer identificationNumber.
	
	customerInDB := self customerWithIDType: aCustomer identificationType andIDNumber: aCustomer identificationNumber.

	self assertCustomer: customerInDB hasFirstName: aCustomer firstName andLastName: aCustomer lastName andAmountOfAddresses: (aCustomer addresses size).
	self assertCustomer: customerInDB hasAddressAtStreet: 'San Martin' atNumber: 3322 atTown: 'Olivos' withZipCode: 1636 atProvince: 'BsAs'.	
	
	self assertCustomer: customerInDB hasAddressAtStreet: 'Maipu' atNumber: 888 atTown: 'Florida' withZipCode: 1122 atProvince: 'Buenos Aires'! !
!Customer methodsFor: 'name' stamp: 'sdf 6/25/2023 16:12:44'!
amountOfAddresses

	^ addresses size.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:12:58' prior: 50627771!
m1: aCustomer

	| customerInDB |

	self assertThereIsOnlyOneCustomerWithIDType: aCustomer identificationType andIDNumber: aCustomer identificationNumber.
	
	customerInDB := self customerWithIDType: aCustomer identificationType andIDNumber: aCustomer identificationNumber.

	self assertCustomer: customerInDB hasFirstName: aCustomer firstName andLastName: aCustomer lastName andAmountOfAddresses: aCustomer amountOfAddresses.
	self assertCustomer: customerInDB hasAddressAtStreet: 'San Martin' atNumber: 3322 atTown: 'Olivos' withZipCode: 1636 atProvince: 'BsAs'.	
	
	self assertCustomer: customerInDB hasAddressAtStreet: 'Maipu' atNumber: 888 atTown: 'Florida' withZipCode: 1122 atProvince: 'Buenos Aires'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:15:12' prior: 50627801!
m1: aCustomer

	| customerInDB |

	self assertThereIsOnlyOneCustomerWithIDType: aCustomer identificationType andIDNumber: aCustomer identificationNumber.
	
	customerInDB := self customerWithIDType: aCustomer identificationType andIDNumber: aCustomer identificationNumber.

	self assertCustomer: customerInDB hasFirstName: aCustomer firstName andLastName: aCustomer lastName andAmountOfAddresses: aCustomer amountOfAddresses.
	
	aCustomer addresses do: [ :anAddress |
		self assertCustomer: customerInDB hasAddressAtStreet: anAddress streetName atNumber: anAddress streetNumber atTown: anAddress town withZipCode: anAddress zipCode atProvince: anAddress province.	
		].! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 16:15:30'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:15:45' prior: 50627745!
test01Import

	| aCustomer |

	self importCustomers.
	self assertAmountOfCustomersIs: 2.
	self assertAmountOfAddressesIs: 3.
	
	self m1: self pepe.
	
	self assertThereIsOnlyOneCustomerWithIDType: 'D' andIDNumber: '22333444'.
	
	aCustomer := self customerWithIDType: 'D' andIDNumber: '22333444'.
	
	self m1: aCustomer.
	
	self assertThereIsOnlyOneCustomerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	aCustomer := self customerWithIDType: 'C' andIDNumber: '23-25666777-9'.
	
	self assertCustomer: aCustomer hasFirstName: 'Juan' andLastName: 'Perez' andAmountOfAddresses: 1.
	
	self assertCustomer: aCustomer hasAddressAtStreet: 'Alem' atNumber: 1122 atTown: 'CABA' withZipCode: 1001 atProvince: 'CABA'.! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 16:15:47'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 16:15:49'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:18:17'!
juan

	| aCustomer firstAddress |
	
	aCustomer := Customer new.
	aCustomer firstName: 'Juan'.
	aCustomer lastName: 'Perez'.
	aCustomer identificationType: 'C'.
	aCustomer identificationNumber: '23-25666777-9'.
	
	firstAddress := Address new.
	firstAddress streetName: 'Alem'.
	firstAddress streetNumber: 1122.
	firstAddress town: 'CABA'.
	firstAddress zipCode: 1001.
	firstAddress province: 'CABA'.
	
	aCustomer addAddress: firstAddress.
	
	^ aCustomer.
		! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:18:28' prior: 50627854!
test01Import

	

	self importCustomers.
	self assertAmountOfCustomersIs: 2.
	self assertAmountOfAddressesIs: 3.
	
	self m1: self pepe.
	
	self m1: self juan.! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 16:18:31'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 16:18:32'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:18:37' prior: 50627902!
test01Import
	self importCustomers.
	self assertAmountOfCustomersIs: 2.
	self assertAmountOfAddressesIs: 3.
	
	self m1: self pepe.
	
	self m1: self juan.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:19:25'!
assertDBHasCustomer: aCustomer

	| customerInDB |

	self assertThereIsOnlyOneCustomerWithIDType: aCustomer identificationType andIDNumber: aCustomer identificationNumber.
	
	customerInDB := self customerWithIDType: aCustomer identificationType andIDNumber: aCustomer identificationNumber.

	self assertCustomer: customerInDB hasFirstName: aCustomer firstName andLastName: aCustomer lastName andAmountOfAddresses: aCustomer amountOfAddresses.
	
	aCustomer addresses do: [ :anAddress |
		self assertCustomer: customerInDB hasAddressAtStreet: anAddress streetName atNumber: anAddress streetNumber atTown: anAddress town withZipCode: anAddress zipCode atProvince: anAddress province.	
		].! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:19:25' prior: 50627915!
test01Import
	self importCustomers.
	self assertAmountOfCustomersIs: 2.
	self assertAmountOfAddressesIs: 3.
	
	self assertDBHasCustomer: self pepe.
	
	self assertDBHasCustomer: self juan.! !

!methodRemoval: ImportTest #m1: stamp: 'sdf 6/25/2023 16:19:25'!
m1: aCustomer

	| customerInDB |

	self assertThereIsOnlyOneCustomerWithIDType: aCustomer identificationType andIDNumber: aCustomer identificationNumber.
	
	customerInDB := self customerWithIDType: aCustomer identificationType andIDNumber: aCustomer identificationNumber.

	self assertCustomer: customerInDB hasFirstName: aCustomer firstName andLastName: aCustomer lastName andAmountOfAddresses: aCustomer amountOfAddresses.
	
	aCustomer addresses do: [ :anAddress |
		self assertCustomer: customerInDB hasAddressAtStreet: anAddress streetName atNumber: anAddress streetNumber atTown: anAddress town withZipCode: anAddress zipCode atProvince: anAddress province.	
		].!

----SNAPSHOT----(25 June 2023 16:19:34) CuisUniversity-5832.image priorSource: 9366758!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:20:56' prior: 50624380!
importCustomers
	| inputStream newCustomer line |
	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber.
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber.
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].

	inputStream close.
	! !

Stream subclass: #StreamSimulator
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #StreamSimulator category: 'CustomerImporter' stamp: 'sdf 6/25/2023 16:22:03'!
Stream subclass: #StreamSimulator
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

ReadStream on: (OrderedCollection with: 'hola' with: 'jaja')!

(ReadStream on: (OrderedCollection with: 'hola' with: 'jaja')) nextLine!

UniFileStream new nextPutAll: 'hola'!

UniFileStream subclass: #StreamSimulator
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #StreamSimulator category: 'CustomerImporter' stamp: 'sdf 6/25/2023 16:32:23'!
UniFileStream subclass: #StreamSimulator
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #StreamSimulator category: 'CustomerImporter' stamp: 'sdf 6/25/2023 16:32:46'!
UniFileStream subclass: #StreamSimulator
	instanceVariableNames: 'lines'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!StreamSimulator methodsFor: 'no messages' stamp: 'sdf 6/25/2023 16:32:45'!
addLine: lineToAdd

	lines add: lineToAdd ! !
!StreamSimulator methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:32:51' prior: 50628056!
addLine: lineToAdd

	lines add: lineToAdd! !
!StreamSimulator methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:33:17' overrides: 16920235!
initialize

	lines := OrderedCollection new.
	position := 0.! !
!StreamSimulator methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:34:12' overrides: 16913973!
nextLine

	
	(position > lines size) ifTrue: [ ^nil ].
	! !
!StreamSimulator methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:35:44' prior: 50628072 overrides: 16913973!
nextLine

	| line |
	
	[ line := lines at: position ] on: Error do: [ ^nil ].
	position := position + 1.
	^ line.
	! !
!StreamSimulator methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:35:47' prior: 50628066 overrides: 16920235!
initialize

	lines := OrderedCollection new.
	position := 1.! !

| sim |
sim := StreamSimulator new initialize.
sim addLine: 'hola'.
sim addLine: 'lol'.

sim nextLine.!

| sim |
sim := StreamSimulator new initialize.
sim addLine: 'hola'.
sim addLine: 'lol'.

sim nextLine nextLine.!

| sim |
sim := StreamSimulator new initialize.
sim addLine: 'hola'.
sim addLine: 'lol'.

sim nextLine.
sim nextLine.!

| sim |
sim := StreamSimulator new initialize.
sim addLine: 'hola'.
sim addLine: 'lol'.

sim nextLine.
sim nextLine.
sim nextLine.!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:38:41'!
streamForTest01

	| streamSim |
	
	streamSim := StreamSimulator new initialize.
	streamSim addLine: 'C,Pepe,Sanchez,D,22333444'.
	streamSim addLine: 'A,San Martin,3322,Olivos,1636,BsAs'.
	streamSim addLine: 'A,Maipu,888,Florida,1122,Buenos Aires'.
	streamSim addLine: 'C,Juan,Perez,C,23-25666777-9'.
	streamSim addLine: 'A,Alem,1122,CABA,1001,CABA'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:40:36' prior: 50627948!
test01Import
	self importCustomersFromStream: (UniFileStream new open: 'input.txt' forWrite: false).
	self assertAmountOfCustomersIs: 2.
	self assertAmountOfAddressesIs: 3.
	
	self assertDBHasCustomer: self pepe.
	
	self assertDBHasCustomer: self juan.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:40:58'!
importCustomersFromStream: inputStream

	| newCustomer line |
	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber.
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber.
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].

	inputStream close.
	! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 16:41:04'!
PASSED!

!methodRemoval: ImportTest #importCustomers stamp: 'sdf 6/25/2023 16:41:08'!
importCustomers
	| inputStream newCustomer line |
	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber.
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber.
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].

	inputStream close.
	!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:41:23' prior: 50628106!
streamForTest01

	| streamSim |
	
	streamSim := StreamSimulator new initialize.
	streamSim addLine: 'C,Pepe,Sanchez,D,22333444'.
	streamSim addLine: 'A,San Martin,3322,Olivos,1636,BsAs'.
	streamSim addLine: 'A,Maipu,888,Florida,1122,Buenos Aires'.
	streamSim addLine: 'C,Juan,Perez,C,23-25666777-9'.
	streamSim addLine: 'A,Alem,1122,CABA,1001,CABA'.
	
	^ streamSim.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:41:37' prior: 50628120!
test01Import
	self importCustomersFromStream: (self streamForTest01).
	self assertAmountOfCustomersIs: 2.
	self assertAmountOfAddressesIs: 3.
	
	self assertDBHasCustomer: self pepe.
	
	self assertDBHasCustomer: self juan.! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 16:41:39'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 16:41:40'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:42:44' prior: 50628218!
test01Import
	self importCustomersFromStream: (self streamForTest01).
	
	self assertAmountOfCustomersIs: 2.
	
	self assertAmountOfAddressesIs: 3.
	
	self assertDBHasCustomer: self pepe.
	
	self assertDBHasCustomer: self juan.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:42:48' prior: 50628233!
test01Import

	self importCustomersFromStream: (self streamForTest01).
	
	self assertAmountOfCustomersIs: 2.
	
	self assertAmountOfAddressesIs: 3.
	
	self assertDBHasCustomer: self pepe.
	
	self assertDBHasCustomer: self juan.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:43:09' prior: 50628131!
importCustomersFromStream: inputStream

	| newCustomer line |
	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber.
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber.
			newAddress province: addressData sixth ].
		line := inputStream nextLine. ].
	inputStream close.
	! !
!ExtractToMethodObjectForm methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:43:35'!
shouldAutoHighlight
	self shouldBeImplemented.! !
!ExtractToMethodObjectForm methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:43:42' prior: 50628289!
shouldAutoHighlight

	^ false! !

!classDefinition: #CustomerImporter category: 'CustomerImporter' stamp: 'sdf 6/25/2023 16:47:07'!
Object subclass: #CustomerImporter
	instanceVariableNames: 'session inputStream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!CustomerImporter class methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:47:07'!
forSession: aSession readingFrom: anInputStream
	^self new initializeForSession: aSession readingFrom: anInputStream! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:47:07'!
initializeForSession: aSession readingFrom: anInputStream
	session := aSession.
	inputStream := anInputStream.! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:47:07' overrides: 16902254!
value

	| newCustomer line |
	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber.
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber.
			newAddress province: addressData sixth ].
		line := inputStream nextLine. ].
	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:47:08' prior: 50628255!
importCustomersFromStream: inputStream
	(CustomerImporter forSession: session readingFrom: inputStream) value! !
!CustomerImporter methodsFor: 'initialization' stamp: 'sdf 6/25/2023 16:47:23' prior: 50628313!
initializeForSession: aSession readingFrom: anInputStream

	session := aSession.
	inputStream := anInputStream.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:47:57' prior: 50628353!
importCustomersFromStream: inputStream

	(CustomerImporter forSession: session readingFrom: inputStream) value! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 16:48:00'!
PASSED!
!StreamSimulator methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:49:58' overrides: 50452924!
nextPutAll: lineToAdd

	lines add: lineToAdd! !

!methodRemoval: StreamSimulator #addLine: stamp: 'sdf 6/25/2023 16:50:00'!
addLine: lineToAdd

	lines add: lineToAdd!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'sdf 6/25/2023 16:50:16' prior: 50628203!
streamForTest01

	| streamSim |
	
	streamSim := StreamSimulator new initialize.
	streamSim nextPutAll: 'C,Pepe,Sanchez,D,22333444'.
	streamSim nextPutAll: 'A,San Martin,3322,Olivos,1636,BsAs'.
	streamSim nextPutAll: 'A,Maipu,888,Florida,1122,Buenos Aires'.
	streamSim nextPutAll: 'C,Juan,Perez,C,23-25666777-9'.
	streamSim nextPutAll: 'A,Alem,1122,CABA,1001,CABA'.
	
	^ streamSim.! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 16:50:19'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 16:50:20'!
PASSED!
!StreamSimulator methodsFor: 'initialization' stamp: 'sdf 6/25/2023 16:54:26' prior: 50628086 overrides: 16920235!
initialize

	collection := OrderedCollection new.
	position := 1.! !

UniFileStream subclass: #StreamSimulator
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #StreamSimulator category: 'CustomerImporter' stamp: 'sdf 6/25/2023 16:54:30'!
UniFileStream subclass: #StreamSimulator
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!StreamSimulator methodsFor: 'accessing' stamp: 'sdf 6/25/2023 16:54:40' prior: 50628078 overrides: 16913973!
nextLine

	| line |
	
	[ line := collection at: position ] on: Error do: [ ^nil ].
	position := position + 1.
	^ line.
	! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 16:54:46'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 16:54:46'!
ERROR!
!StreamSimulator methodsFor: 'read, write, position' stamp: 'sdf 6/25/2023 16:54:55' prior: 50628377 overrides: 50452924!
nextPutAll: lineToAdd

	collection add: lineToAdd! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 16:55:03'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'sdf 6/25/2023 16:55:47' prior: 50628244!
test01Import

	self importCustomersFromStream: self streamForTest01.
	
	self assertAmountOfCustomersIs: 2.
	
	self assertAmountOfAddressesIs: 3.
	
	self assertDBHasCustomer: self pepe.
	
	self assertDBHasCustomer: self juan.! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 16:55:49'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 16:55:50'!
PASSED!

----SNAPSHOT----(25 June 2023 16:56:18) CuisUniversity-5832.image priorSource: 9482529!

----STARTUP---- (25 June 2023 17:00:14) as C:\Users\Santii\Desktop\UBA\inge1\windows64\CuisUniversity-5832.image!


!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 17:01:12'!
PASSED!

----STARTUP---- (25 June 2023 18:15:53) as C:\Users\Santii\Desktop\UBA\inge1\windows64\CuisUniversity-5832.image!

!ImportTest methodsFor: 'auxiliar' stamp: 'sdf 6/25/2023 18:16:36' prior: 50628386!
streamForTest01

	ReadStream on: 'C,Pepe,Sanchez,D,22333444
				      A,San Martin,3322,Olivos,1636,BsAs
				      A,Maipu,888,Florida,1122,Buenos Aires
				      C,Juan,Perez,C,23-25666777-9
				      A,Alem,1122,CABA,1001,CABA'.! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 18:16:39'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 18:16:39'!
ERROR!
!ImportTest methodsFor: 'auxiliar' stamp: 'sdf 6/25/2023 18:17:24' prior: 50628473!
streamForTest01

	^ ReadStream on: 'C,Pepe,Sanchez,D,22333444
					 A,San Martin,3322,Olivos,1636,BsAs
					 A,Maipu,888,Florida,1122,Buenos Aires
					 C,Juan,Perez,C,23-25666777-9
					 A,Alem,1122,CABA,1001,CABA'.! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 18:17:27'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 18:17:28'!
FAILURE!
!ImportTest methodsFor: 'auxiliar' stamp: 'sdf 6/25/2023 18:17:45' prior: 50628488!
streamForTest01

	^ ReadStream on: 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA'.! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 18:17:47'!
PASSED!
!ImportTest methodsFor: 'auxiliar' stamp: 'sdf 6/25/2023 18:17:57' prior: 50628503!
streamForTest01

	^ ReadStream on: 'C,Pepe,Sanchez,D,22333444
					A,San Martin,3322,Olivos,1636,BsAs
					A,Maipu,888,Florida,1122,Buenos Aires
					C,Juan,Perez,C,23-25666777-9
					A,Alem,1122,CABA,1001,CABA'.! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 18:17:59'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 18:17:59'!
FAILURE!
!ImportTest methodsFor: 'auxiliar' stamp: 'sdf 6/25/2023 18:18:20' prior: 50628515!
streamForTest01

	ReadStream on: 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA'.! !
!ImportTest methodsFor: 'auxiliar' stamp: 'sdf 6/25/2023 18:18:51' prior: 50628530!
streamForTest01

	ReadStream on:
		'C,Pepe,Sanchez,D,22333444
		A,San Martin,3322,Olivos,1636,BsAs
		A,Maipu,888,Florida,1122,Buenos Aires
		C,Juan,Perez,C,23-25666777-9
		A,Alem,1122,CABA,1001,CABA'.
	



! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 18:18:52'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 18:18:52'!
ERROR!
!ImportTest methodsFor: 'auxiliar' stamp: 'sdf 6/25/2023 18:18:58' prior: 50628539!
streamForTest01

	^ ReadStream on:
		'C,Pepe,Sanchez,D,22333444
		A,San Martin,3322,Olivos,1636,BsAs
		A,Maipu,888,Florida,1122,Buenos Aires
		C,Juan,Perez,C,23-25666777-9
		A,Alem,1122,CABA,1001,CABA'.
	



! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 18:18:58'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 18:18:59'!
FAILURE!
!ImportTest methodsFor: 'auxiliar' stamp: 'sdf 6/25/2023 18:19:09' prior: 50628553!
streamForTest01

	^ ReadStream on:
		'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA'.
	



! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 18:19:11'!
PASSED!
!ImportTest methodsFor: 'auxiliar' stamp: 'sdf 6/25/2023 18:19:32' prior: 50628568!
streamForTest01

	^ ReadStream on:
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA'.
	



! !
!ImportTest methodsFor: 'auxiliar' stamp: 'sdf 6/25/2023 18:19:39' prior: 50628580!
streamForTest01

	^ ReadStream on:
	'C,Pepe,Sanchez,D,22333444
	A,San Martin,3322,Olivos,1636,BsAs
	A,Maipu,888,Florida,1122,Buenos Aires
	C,Juan,Perez,C,23-25666777-9
	A,Alem,1122,CABA,1001,CABA'.
	



! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 18:19:40'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 18:19:40'!
FAILURE!
!ImportTest methodsFor: 'auxiliar' stamp: 'sdf 6/25/2023 18:21:06' prior: 50628589!
streamForTest01

	^ ReadStream on:
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA'.
	



! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 18:21:09'!
PASSED!
!ImportTest methodsFor: 'auxiliar' stamp: 'sdf 6/25/2023 18:21:23' prior: 50628604!
streamForTest01

	^ ReadStream on: (
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA'
	)
	



! !

!classRemoval: #StreamSimulator stamp: 'sdf 6/25/2023 18:21:49'!
UniFileStream subclass: #StreamSimulator
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!ImportTest methodsFor: 'tests' stamp: 'sdf 6/25/2023 18:23:16' prior: 50628445!
test01Import

	self importCustomersFromStream: self streamForTest01.
	
	self assertAmountOfCustomersIs: 2.
	self assertAmountOfAddressesIs: 3.
	
	self assertDBHasCustomer: self pepe.
	self assertDBHasCustomer: self juan.! !
!ImportTest methodsFor: 'asserting' stamp: 'sdf 6/25/2023 18:23:29' prior: 50627620!
assertAmountOfAddressesIs: amountOfAddresses

	^ self assert: amountOfAddresses
		  equals: ((session selectAllOfType: Customer) sum: [ :customer | customer addresses size ])! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 18:23:32'!
PASSED!
!ImportTest methodsFor: 'asserting' stamp: 'sdf 6/25/2023 18:23:41' prior: 50627435!
assertAmountOfCustomersIs: amountOfCustomers

	^ self assert: amountOfCustomers 
		  equals: (session selectAllOfType: Customer) size! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 18:23:42'!
PASSED!
!ImportTest methodsFor: 'setUp/tearDown' stamp: 'sdf 6/25/2023 18:24:33' prior: 50624490 overrides: 16961402!
tearDown

	session commit.
	
	session close! !
!ImportTest methodsFor: 'setUp/tearDown' stamp: 'sdf 6/25/2023 18:24:35' prior: 50628664 overrides: 16961402!
tearDown

	session commit.
	
	session close.! !
!ImportTest methodsFor: 'setUp/tearDown' stamp: 'sdf 6/25/2023 18:24:44' prior: 50624483 overrides: 16961394!
setUp
	
	session := DataBaseSession for: (Array with: Address with: Customer).
	
	session beginTransaction.! !
!ImportTest methodsFor: 'asserting' stamp: 'sdf 6/25/2023 18:25:44' prior: 50628642!
assertAmountOfAddressesIs: amountOfAddresses

	^ self assert: amountOfAddresses
		  equals: ((session selectAllOfType: Customer) sum: [ :customer | customer amountOfAddresses ])! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 18:25:46'!
PASSED!
!ImportTest methodsFor: 'asserting' stamp: 'sdf 6/25/2023 18:26:18' prior: 50625754!
assertCustomer: aCustomer hasFirstName: customerName andLastName: customerLastName andAmountOfAddresses: amountOfAddresses   

	self assert: customerName equals: aCustomer firstName.
	self assert: customerLastName equals: aCustomer lastName.
	self assert: amountOfAddresses equals: aCustomer amountOfAddresses.! !

!testRun: #ImportTest #test01Import stamp: 'sdf 6/25/2023 18:26:20'!
PASSED!

----SNAPSHOT----(25 June 2023 18:28:49) CuisUniversity-5832.image priorSource: 9497887!

----STARTUP---- (25 June 2023 18:42:43) as C:\Users\Santii\Desktop\UBA\inge1\windows64\CuisUniversity-5832.image!

!ImportTest methodsFor: 'tests' stamp: 'sdf 6/25/2023 18:43:38'!
Test01CustomersInformationAndAddressesAreImported

	self importCustomersFromStream: self streamForTest01.
	
	self assertAmountOfCustomersIs: 2.
	self assertAmountOfAddressesIs: 3.
	
	self assertDBHasCustomer: self pepe.
	self assertDBHasCustomer: self juan.! !

!methodRemoval: ImportTest #test01Import stamp: 'sdf 6/25/2023 18:43:38'!
test01Import

	self importCustomersFromStream: self streamForTest01.
	
	self assertAmountOfCustomersIs: 2.
	self assertAmountOfAddressesIs: 3.
	
	self assertDBHasCustomer: self pepe.
	self assertDBHasCustomer: self juan.!
!ImportTest methodsFor: 'tests' stamp: 'sdf 6/25/2023 18:43:48'!
test01CustomersInformationAndAddressesAreImported

	self importCustomersFromStream: self streamForTest01.
	
	self assertAmountOfCustomersIs: 2.
	self assertAmountOfAddressesIs: 3.
	
	self assertDBHasCustomer: self pepe.
	self assertDBHasCustomer: self juan.! !

!methodRemoval: ImportTest #Test01CustomersInformationAndAddressesAreImported stamp: 'sdf 6/25/2023 18:43:48'!
Test01CustomersInformationAndAddressesAreImported

	self importCustomersFromStream: self streamForTest01.
	
	self assertAmountOfCustomersIs: 2.
	self assertAmountOfAddressesIs: 3.
	
	self assertDBHasCustomer: self pepe.
	self assertDBHasCustomer: self juan.!

----SNAPSHOT----(25 June 2023 18:44:29) CuisUniversity-5832.image priorSource: 9505801!

----STARTUP---- (26 June 2023 17:15:48) as /home/clinux01/Descargas/linux64/CuisUniversity-5832.image!


----End fileIn of /home/clinux01/Descargas/linux64/CustomerImporter.st----!
!ImportTest methodsFor: 'auxiliar' stamp: 'p 6/26/2023 18:47:24'!
streamWithValidCustomers

	^ ReadStream on: (
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA'
	)
	



! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'p 6/26/2023 18:47:24' prior: 50624456!
test01CustomersInformationAndAddressesAreImported

	self importCustomersFromStream: self streamWithValidCustomers.
	
	self assertAmountOfCustomersIs: 2.
	self assertAmountOfAddressesIs: 3.
	
	self assertDBHasCustomer: self pepe.
	self assertDBHasCustomer: self juan.! !

!methodRemoval: ImportTest #streamForTest01 stamp: 'p 6/26/2023 18:47:24'!
streamForTest01

	^ ReadStream on: (
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA'
	)
	



!
!ImportTest methodsFor: 'auxiliar' stamp: 'p 6/26/2023 18:47:32'!
streamWithValidCustomersData

	^ ReadStream on: (
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA'
	)
	



! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'p 6/26/2023 18:47:32' prior: 50624846!
test01CustomersInformationAndAddressesAreImported

	self importCustomersFromStream: self streamWithValidCustomersData.
	
	self assertAmountOfCustomersIs: 2.
	self assertAmountOfAddressesIs: 3.
	
	self assertDBHasCustomer: self pepe.
	self assertDBHasCustomer: self juan.! !

!methodRemoval: ImportTest #streamWithValidCustomers stamp: 'p 6/26/2023 18:47:32'!
streamWithValidCustomers

	^ ReadStream on: (
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA'
	)
	



!

!testRun: #ImportTest #test01CustomersInformationAndAddressesAreImported stamp: 'p 6/26/2023 18:47:38'!
PASSED!

!classRemoval: #DataBaseSession stamp: 'p 6/26/2023 18:49:48'!
Object subclass: #DataBaseSession
	instanceVariableNames: 'configuration tables id'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #CustomerImporter stamp: 'p 6/26/2023 18:49:48'!
Object subclass: #CustomerImporter
	instanceVariableNames: 'session inputStream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #Customer stamp: 'p 6/26/2023 18:49:49'!
Object subclass: #Customer
	instanceVariableNames: 'id firstName lastName identificationType identificationNumber addresses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #Address stamp: 'p 6/26/2023 18:49:49'!
Object subclass: #Address
	instanceVariableNames: 'id streetName streetNumber town zipCode province'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #ImportTest stamp: 'p 6/26/2023 18:49:49'!
TestCase subclass: #ImportTest
	instanceVariableNames: 'session'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

----STARTUP---- (26 June 2023 19:09:32) as /home/clinux01/Descargas/linux64/CuisUniversity-5832.image!


----End fileIn of /home/clinux01/Descargas/linux64/CustomerImporter-35.st----!
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:10:33' prior: 50625202 overrides: 16902254!
value

	"
	self importCustomers
	"
	| newCustomer1 line |

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData newCustomer |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer1 addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:10:49'!
addCustomer: line

	| customerData newCustomer |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:10:49' prior: 50625354 overrides: 16902254!
value

	"
	self importCustomers
	"
	| newCustomer1 line |

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ self addCustomer: line ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer1 addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:10:58' prior: 50625386!
addCustomer: line

	| customerData newCustomer |
			
	customerData := line findTokens: $,.
	newCustomer := Customer new.
	newCustomer firstName: customerData second.
	newCustomer lastName: customerData third.
	newCustomer identificationType: customerData fourth.
	newCustomer identificationNumber: customerData fifth.
	session persist: newCustomer! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:11:19' prior: 50625401 overrides: 16902254!
value

	"
	self importCustomers
	"
	| line |

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ self addCustomer: line ].

		(line beginsWith: 'A') ifTrue: [ | newCustomer addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:11:50' prior: 50625424!
addCustomer: line

	| customerData newCustomer |
			
	customerData := line findTokens: $,.
	newCustomer := Customer new.
	newCustomer firstName: customerData second.
	newCustomer lastName: customerData third.
	newCustomer identificationType: customerData fourth.
	newCustomer identificationNumber: customerData fifth.
	
	^ newCustomer! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:12:31' prior: 50625439 overrides: 16902254!
value

	"
	self importCustomers
	"
	| line newCustomer |

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [
			newCustomer := self addCustomer: line.
			session persist: newCustomer
			].
	
		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:13:02'!
addAddressFrom: newCustomer toCustomer: line

	| addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:13:02' prior: 50625477 overrides: 16902254!
value

	"
	self importCustomers
	"
	| line newCustomer |

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [
			newCustomer := self addCustomer: line.
			session persist: newCustomer
			].
	
		(line beginsWith: 'A') ifTrue: [ self addAddressFrom: newCustomer toCustomer: line ].

		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:13:15'!
createCustomerObjectFromLine: line

	| customerData newCustomer |
			
	customerData := line findTokens: $,.
	newCustomer := Customer new.
	newCustomer firstName: customerData second.
	newCustomer lastName: customerData third.
	newCustomer identificationType: customerData fourth.
	newCustomer identificationNumber: customerData fifth.
	
	^ newCustomer! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'dsf 6/26/2023 19:13:15' prior: 50625518 overrides: 16902254!
value

	"
	self importCustomers
	"
	| line newCustomer |

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [
			newCustomer := self createCustomerObjectFromLine: line.
			session persist: newCustomer
			].
	
		(line beginsWith: 'A') ifTrue: [ self addAddressFrom: newCustomer toCustomer: line ].

		line := readStream nextLine. ].

	! !

!methodRemoval: CustomerImporter #addCustomer: stamp: 'dsf 6/26/2023 19:13:15'!
addCustomer: line

	| customerData newCustomer |
			
	customerData := line findTokens: $,.
	newCustomer := Customer new.
	newCustomer firstName: customerData second.
	newCustomer lastName: customerData third.
	newCustomer identificationType: customerData fourth.
	newCustomer identificationNumber: customerData fifth.
	
	^ newCustomer!
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:13:26' prior: 50625547 overrides: 16902254!
value

	"
	self importCustomers
	"
	| line newCustomer |

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [
			newCustomer := self createCustomerObjectFromLine: line.
			session persist: newCustomer
			].
	
		(line beginsWith: 'A') ifTrue: [
			self addAddressFrom: newCustomer toCustomer: line
			].

		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:13:32' prior: 50625576 overrides: 16902254!
value

	"
	self importCustomers
	"
	| line newCustomer |

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [
			newCustomer := self createCustomerObjectFromLine: line.
			session persist: newCustomer
			].
	
		(line beginsWith: 'A') ifTrue: [
			self addAddressFrom: newCustomer toCustomer: line
			].

		line := readStream nextLine.
		].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:13:43' prior: 50625501!
addAddressFrom: newCustomer toCustomer: line

	| addressData newAddress |
	
	addressData := line findTokens: $,.
	newAddress := Address new.
	newCustomer addAddress: newAddress.
	newAddress streetName: addressData second.
	newAddress streetNumber: addressData third asNumber .
	newAddress town: addressData fourth.
	newAddress zipCode: addressData fifth asNumber .
	newAddress province: addressData sixth! !

!testRun: #ImportTest #test01Import stamp: 'dsf 6/26/2023 19:13:45'!
PASSED!
!CustomerImporter methodsFor: 'initialization' stamp: 'dsf 6/26/2023 19:13:51' prior: 50625196!
initializeFrom: aReadStream into: aSession

	session := aSession.
	readStream := aReadStream.! !
!ImportTest methodsFor: 'test data' stamp: 'dsf 6/26/2023 19:14:25'!
emptyImportData

	^ ReadStream on: ''! !
!ImportTest methodsFor: 'test data' stamp: 'dsf 6/26/2023 19:15:20'!
addressFirstImportData

	^ ReadStream on:
'A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA'! !
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:16:26'!
test02

	CustomerImporter valueFrom: self emptyImportData into: session.
	! !
!ImportTest methodsFor: 'assertions' stamp: 'dsf 6/26/2023 19:16:48'!
assertImportedRightNumberOfCustomers: amountOfCustomers

	^ self assert: 2 equals: (session selectAllOfType: Customer) size! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'dsf 6/26/2023 19:16:48' prior: 50624951!
test01Import

	CustomerImporter valueFrom: self validImportData into: session..

	self assertImportedRightNumberOfCustomers: 2.
	self assertPepeSanchezWasImportedCorrecty.
	self assertJuanPerezWasImportedCorrectly ! !

!methodRemoval: ImportTest #assertImportedRightNumberOfCustomers stamp: 'dsf 6/26/2023 19:16:48'!
assertImportedRightNumberOfCustomers

	^ self assert: 2 equals: (session selectAllOfType: Customer) size!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'dsf 6/26/2023 19:16:48' prior: 50625650!
assertImportedRightNumberOfCustomers: amountOfCustomers

	^ self assert: amountOfCustomers equals: (session selectAllOfType: Customer) size! !
!ImportTest methodsFor: 'assertions' stamp: 'dsf 6/26/2023 19:17:05'!
assertAmountOfImportedCustomersIs: amountOfCustomers

	^ self assert: amountOfCustomers equals: (session selectAllOfType: Customer) size! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'dsf 6/26/2023 19:17:05' prior: 50625657!
test01Import

	CustomerImporter valueFrom: self validImportData into: session..

	self assertAmountOfImportedCustomersIs: 2.
	self assertPepeSanchezWasImportedCorrecty.
	self assertJuanPerezWasImportedCorrectly ! !

!methodRemoval: ImportTest #assertImportedRightNumberOfCustomers: stamp: 'dsf 6/26/2023 19:17:05'!
assertImportedRightNumberOfCustomers: amountOfCustomers

	^ self assert: amountOfCustomers equals: (session selectAllOfType: Customer) size!
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:17:27' prior: 50625645!
test02

	CustomerImporter valueFrom: self emptyImportData into: session.
	
	self assertAmountOfImportedCustomersIs: 0.! !

!testRun: #ImportTest #test02 stamp: 'dsf 6/26/2023 19:17:29'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'dsf 6/26/2023 19:17:29'!
PASSED!

!testRun: #ImportTest #test02 stamp: 'dsf 6/26/2023 19:17:30'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:19:25'!
test03

	
	
	self should: [ CustomerImporter valueFrom: self emptyImportData into: session. ]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: CustomerImporter invalidInputStreamErrorDescription
			       equals: anError messageText
				]! !
!CustomerImporter class methodsFor: 'importing' stamp: 'dsf 6/26/2023 19:19:46'!
invalidInputStreamErrorDescription

	^ 'Stream de entrada invalido'! !

!testRun: #ImportTest #test03 stamp: 'dsf 6/26/2023 19:19:55'!
FAILURE!

!testRun: #ImportTest #test03 stamp: 'dsf 6/26/2023 19:19:55'!
FAILURE!
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:21:12' prior: 50625592 overrides: 16902254!
value

	"
	self importCustomers
	"
	| line newCustomer |

	line := readStream nextLine.
	(line beginsWith: 'A') ifTrue: [ self error: self class invalidInputStreamErrorDescription ].
	
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [
			newCustomer := self createCustomerObjectFromLine: line.
			session persist: newCustomer
			].
	
		(line beginsWith: 'A') ifTrue: [
			self addAddressFrom: newCustomer toCustomer: line
			].

		line := readStream nextLine.
		].

	! !

!testRun: #ImportTest #test01Import stamp: 'dsf 6/26/2023 19:21:19'!
PASSED!

!testRun: #ImportTest #test02 stamp: 'dsf 6/26/2023 19:21:20'!
ERROR!

!testRun: #ImportTest #test03 stamp: 'dsf 6/26/2023 19:21:20'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'dsf 6/26/2023 19:21:23'!
PASSED!

!testRun: #ImportTest #test02 stamp: 'dsf 6/26/2023 19:21:25'!
ERROR!

!testRun: #ImportTest #test02 stamp: 'dsf 6/26/2023 19:21:25'!
ERROR!

!testRun: #ImportTest #test03 stamp: 'dsf 6/26/2023 19:22:13'!
FAILURE!

!testRun: #ImportTest #test03 stamp: 'dsf 6/26/2023 19:22:13'!
FAILURE!

self class invalidInputStreamErrorDescription!

!testRun: #ImportTest #test03 stamp: 'dsf 6/26/2023 19:23:18'!
FAILURE!

!testRun: #ImportTest #test03 stamp: 'dsf 6/26/2023 19:23:18'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:24:10' prior: 50625719!
test03

	
	
	self should: [ CustomerImporter valueFrom: self addressFirstImportData into: session. ]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: CustomerImporter invalidInputStreamErrorDescription
			       equals: anError messageText
				]! !

!testRun: #ImportTest #test03 stamp: 'dsf 6/26/2023 19:24:10'!
PASSED!

!testRun: #ImportTest #test02 stamp: 'dsf 6/26/2023 19:24:12'!
ERROR!

!testRun: #ImportTest #test02 stamp: 'dsf 6/26/2023 19:24:12'!
ERROR!
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:24:48' prior: 50625741 overrides: 16902254!
value

	"
	self importCustomers
	"
	| line newCustomer |

	line := readStream nextLine.
	((line beginsWith: 'A') and: line isNotNil) ifTrue: [ self error: self class invalidInputStreamErrorDescription ].
	
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [
			newCustomer := self createCustomerObjectFromLine: line.
			session persist: newCustomer
			].
	
		(line beginsWith: 'A') ifTrue: [
			self addAddressFrom: newCustomer toCustomer: line
			].

		line := readStream nextLine.
		].

	! !

!testRun: #ImportTest #test01Import stamp: 'dsf 6/26/2023 19:24:51'!
ERROR!

!testRun: #ImportTest #test02 stamp: 'dsf 6/26/2023 19:24:51'!
ERROR!

!testRun: #ImportTest #test03 stamp: 'dsf 6/26/2023 19:24:51'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'dsf 6/26/2023 19:24:57'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'dsf 6/26/2023 19:24:57'!
ERROR!
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:25:31' prior: 50625803 overrides: 16902254!
value

	"
	self importCustomers
	"
	| line newCustomer |

	line := readStream nextLine.
	(line isNotNil and: (line beginsWith: 'A')) ifTrue: [ self error: self class invalidInputStreamErrorDescription ].
	
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [
			newCustomer := self createCustomerObjectFromLine: line.
			session persist: newCustomer
			].
	
		(line beginsWith: 'A') ifTrue: [
			self addAddressFrom: newCustomer toCustomer: line
			].

		line := readStream nextLine.
		].

	! !

!testRun: #ImportTest #test01Import stamp: 'dsf 6/26/2023 19:25:35'!
ERROR!

!testRun: #ImportTest #test02 stamp: 'dsf 6/26/2023 19:25:36'!
ERROR!

!testRun: #ImportTest #test03 stamp: 'dsf 6/26/2023 19:25:36'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'dsf 6/26/2023 19:25:38'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'dsf 6/26/2023 19:25:38'!
ERROR!
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:25:48' prior: 50625835 overrides: 16902254!
value

	"
	self importCustomers
	"
	| line newCustomer |

	line := readStream nextLine.
	(line notNil and: (line beginsWith: 'A')) ifTrue: [ self error: self class invalidInputStreamErrorDescription ].
	
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [
			newCustomer := self createCustomerObjectFromLine: line.
			session persist: newCustomer
			].
	
		(line beginsWith: 'A') ifTrue: [
			self addAddressFrom: newCustomer toCustomer: line
			].

		line := readStream nextLine.
		].

	! !

!testRun: #ImportTest #test01Import stamp: 'dsf 6/26/2023 19:25:51'!
PASSED!

!testRun: #ImportTest #test02 stamp: 'dsf 6/26/2023 19:25:51'!
ERROR!

!testRun: #ImportTest #test03 stamp: 'dsf 6/26/2023 19:25:51'!
PASSED!

!testRun: #ImportTest #test02 stamp: 'dsf 6/26/2023 19:25:51'!
ERROR!

!testRun: #ImportTest #test02 stamp: 'dsf 6/26/2023 19:26:41'!
ERROR!

!testRun: #ImportTest #test02 stamp: 'dsf 6/26/2023 19:26:41'!
ERROR!
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:27:35' prior: 50625867 overrides: 16902254!
value

	"
	self importCustomers
	"
	| line newCustomer |

	line := readStream nextLine.
	line notNil ifTrue: [ (line beginsWith: 'A') ifTrue: [ self error: self class invalidInputStreamErrorDescription ] ].
	
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [
			newCustomer := self createCustomerObjectFromLine: line.
			session persist: newCustomer
			].
	
		(line beginsWith: 'A') ifTrue: [
			self addAddressFrom: newCustomer toCustomer: line
			].

		line := readStream nextLine.
		].

	! !

!testRun: #ImportTest #test01Import stamp: 'dsf 6/26/2023 19:27:43'!
PASSED!

!testRun: #ImportTest #test02 stamp: 'dsf 6/26/2023 19:27:43'!
PASSED!

!testRun: #ImportTest #test03 stamp: 'dsf 6/26/2023 19:27:43'!
PASSED!
!ImportTest methodsFor: 'test data' stamp: 'dsf 6/26/2023 19:29:40'!
invalidWithMoreFieldsImportData

	^ ReadStream on:
'C,Pepe,Sanchez,D,22333444,jaja'! !
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:30:04'!
test04

	CustomerImporter valueFrom: self invalidWithMoreFieldsImportData into: session.! !

!testRun: #ImportTest #test04 stamp: 'dsf 6/26/2023 19:30:07'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'dsf 6/26/2023 19:30:07'!
PASSED!

!testRun: #ImportTest #test02 stamp: 'dsf 6/26/2023 19:30:07'!
PASSED!

!testRun: #ImportTest #test03 stamp: 'dsf 6/26/2023 19:30:08'!
PASSED!

!testRun: #ImportTest #test04 stamp: 'dsf 6/26/2023 19:30:08'!
PASSED!
!ImportTest methodsFor: 'test data' stamp: 'dsf 6/26/2023 19:30:20' prior: 50625926!
invalidWithMoreFieldsImportData

	^ ReadStream on:
'C,Pepe,Sanchez,D'! !

!testRun: #ImportTest #test04 stamp: 'dsf 6/26/2023 19:30:23'!
ERROR!

!testRun: #ImportTest #test04 stamp: 'dsf 6/26/2023 19:30:23'!
ERROR!
!ImportTest methodsFor: 'test data' stamp: 'dsf 6/26/2023 19:30:47'!
invalidWithNotEnoughFieldsImportData

	^ ReadStream on:
'C,Pepe,Sanchez,D'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'dsf 6/26/2023 19:30:47' prior: 50625931!
test04

	CustomerImporter valueFrom: self invalidWithNotEnoughFieldsImportData into: session.! !

!methodRemoval: ImportTest #invalidWithMoreFieldsImportData stamp: 'dsf 6/26/2023 19:30:47'!
invalidWithMoreFieldsImportData

	^ ReadStream on:
'C,Pepe,Sanchez,D'!
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:31:47' prior: 50625784!
test03

	self should: [ CustomerImporter valueFrom: self addressFirstImportData into: session. ]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: CustomerImporter invalidInputStreamErrorDescription
			       equals: anError messageText
				]! !
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:32:04' prior: 50625963!
test04

	self should: [ CustomerImporter valueFrom: self invalidWithNotEnoughFieldsImportData into: session. ]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: CustomerImporter invalidInputStreamErrorDescription
			       equals: anError messageText
				]! !

!testRun: #ImportTest #test04 stamp: 'dsf 6/26/2023 19:32:05'!
FAILURE!
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:34:16' prior: 50625532!
createCustomerObjectFromLine: line

	| customerData newCustomer |
			
	customerData := line findTokens: $,.
	(customerData size = 5) ifFalse: [ self error: self class invalidInputStreamErrorDescription ].
	newCustomer := Customer new.
	newCustomer firstName: customerData second.
	newCustomer lastName: customerData third.
	newCustomer identificationType: customerData fourth.
	newCustomer identificationNumber: customerData fifth.
	
	^ newCustomer! !

!testRun: #ImportTest #test01Import stamp: 'dsf 6/26/2023 19:34:24'!
PASSED!

!testRun: #ImportTest #test02 stamp: 'dsf 6/26/2023 19:34:24'!
PASSED!

!testRun: #ImportTest #test03 stamp: 'dsf 6/26/2023 19:34:24'!
PASSED!

!testRun: #ImportTest #test04 stamp: 'dsf 6/26/2023 19:34:24'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:34:57'!
test05

	self should: [ CustomerImporter valueFrom: self invalidWithNotEnoughFieldsInAddressImportData into: session. ]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: CustomerImporter invalidInputStreamErrorDescription
			       equals: anError messageText
				]! !
!ImportTest methodsFor: 'test data' stamp: 'dsf 6/26/2023 19:35:13'!
invalidWithNotEnoughFieldsInCustomerImportData

	^ ReadStream on:
'C,Pepe,Sanchez,D'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'dsf 6/26/2023 19:35:13' prior: 50625985!
test04

	self should: [ CustomerImporter valueFrom: self invalidWithNotEnoughFieldsInCustomerImportData into: session. ]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: CustomerImporter invalidInputStreamErrorDescription
			       equals: anError messageText
				]! !

!methodRemoval: ImportTest #invalidWithNotEnoughFieldsImportData stamp: 'dsf 6/26/2023 19:35:13'!
invalidWithNotEnoughFieldsImportData

	^ ReadStream on:
'C,Pepe,Sanchez,D'!
!ImportTest methodsFor: 'test data' stamp: 'dsf 6/26/2023 19:35:44' prior: 50626036!
invalidWithNotEnoughFieldsInCustomerImportData

	^ ReadStream on:
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636'! !
!ImportTest methodsFor: 'test data' stamp: 'dsf 6/26/2023 19:36:07' prior: 50626059!
invalidWithNotEnoughFieldsInCustomerImportData

	^ ReadStream on: 'C,Pepe,Sanchez,D,'! !
!ImportTest methodsFor: 'test data' stamp: 'dsf 6/26/2023 19:36:36'!
invalidWithNotEnoughFieldsInAddressImportData

	^ ReadStream on:
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636'! !

!testRun: #ImportTest #test05 stamp: 'dsf 6/26/2023 19:36:43'!
FAILURE!
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:37:04' prior: 50625608!
addAddressFrom: newCustomer toCustomer: line

	| addressData newAddress |
	
	addressData := line findTokens: $,.
	(addressData size = 5) ifFalse: [ self error: self class invalidInputStreamErrorDescription ].
	newAddress := Address new.
	newCustomer addAddress: newAddress.
	newAddress streetName: addressData second.
	newAddress streetNumber: addressData third asNumber .
	newAddress town: addressData fourth.
	newAddress zipCode: addressData fifth asNumber .
	newAddress province: addressData sixth! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:37:31' prior: 50626081!
addAddressFrom: newCustomer toCustomer: line

	| addressData newAddress |
	
	addressData := line findTokens: $,.
	(addressData size = 6) ifFalse: [ self error: self class invalidInputStreamErrorDescription ].
	newAddress := Address new.
	newCustomer addAddress: newAddress.
	newAddress streetName: addressData second.
	newAddress streetNumber: addressData third asNumber .
	newAddress town: addressData fourth.
	newAddress zipCode: addressData fifth asNumber .
	newAddress province: addressData sixth! !

!testRun: #ImportTest #test01Import stamp: 'dsf 6/26/2023 19:37:36'!
PASSED!

!testRun: #ImportTest #test02 stamp: 'dsf 6/26/2023 19:37:37'!
PASSED!

!testRun: #ImportTest #test03 stamp: 'dsf 6/26/2023 19:37:37'!
PASSED!

!testRun: #ImportTest #test04 stamp: 'dsf 6/26/2023 19:37:37'!
PASSED!

!testRun: #ImportTest #test05 stamp: 'dsf 6/26/2023 19:37:37'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:37:54'!
test02EmptyFile

	CustomerImporter valueFrom: self emptyImportData into: session.
	
	self assertAmountOfImportedCustomersIs: 0.! !

!methodRemoval: ImportTest #test02 stamp: 'dsf 6/26/2023 19:37:56'!
test02

	CustomerImporter valueFrom: self emptyImportData into: session.
	
	self assertAmountOfImportedCustomersIs: 0.!
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:38:09'!
test03addressFist

	self should: [ CustomerImporter valueFrom: self addressFirstImportData into: session. ]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: CustomerImporter invalidInputStreamErrorDescription
			       equals: anError messageText
				]! !

!methodRemoval: ImportTest #test03 stamp: 'dsf 6/26/2023 19:38:09'!
test03

	self should: [ CustomerImporter valueFrom: self addressFirstImportData into: session. ]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: CustomerImporter invalidInputStreamErrorDescription
			       equals: anError messageText
				]!
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:38:14'!
test03addressFirst

	self should: [ CustomerImporter valueFrom: self addressFirstImportData into: session. ]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: CustomerImporter invalidInputStreamErrorDescription
			       equals: anError messageText
				]! !

!methodRemoval: ImportTest #test03addressFist stamp: 'dsf 6/26/2023 19:38:14'!
test03addressFist

	self should: [ CustomerImporter valueFrom: self addressFirstImportData into: session. ]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: CustomerImporter invalidInputStreamErrorDescription
			       equals: anError messageText
				]!
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:38:24'!
test04notEnoughFieldsInCustomer

	self should: [ CustomerImporter valueFrom: self invalidWithNotEnoughFieldsInCustomerImportData into: session. ]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: CustomerImporter invalidInputStreamErrorDescription
			       equals: anError messageText
				]! !

!methodRemoval: ImportTest #test04 stamp: 'dsf 6/26/2023 19:38:24'!
test04

	self should: [ CustomerImporter valueFrom: self invalidWithNotEnoughFieldsInCustomerImportData into: session. ]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: CustomerImporter invalidInputStreamErrorDescription
			       equals: anError messageText
				]!
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:38:34'!
test05notEnoughFieldsInAddress

	self should: [ CustomerImporter valueFrom: self invalidWithNotEnoughFieldsInAddressImportData into: session. ]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: CustomerImporter invalidInputStreamErrorDescription
			       equals: anError messageText
				]! !

!methodRemoval: ImportTest #test05 stamp: 'dsf 6/26/2023 19:38:34'!
test05

	self should: [ CustomerImporter valueFrom: self invalidWithNotEnoughFieldsInAddressImportData into: session. ]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: CustomerImporter invalidInputStreamErrorDescription
			       equals: anError messageText
				]!
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:40:15' prior: 50626209!
test05notEnoughFieldsInAddress
	" CustomerImporter valueFrom: self invalidWithNotEnoughFieldsInAddressImportData into: session. "
	| aClosure |
	self should: aClosure value
		raise: Error
		withExceptionDo: [ :anError |
			self assert: CustomerImporter invalidInputStreamErrorDescription
			       equals: anError messageText
				]! !
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:40:37'!
assertClosureRaisesInvalidInputError: aClosure

	^ self should: aClosure value
		raise: Error
		withExceptionDo: [ :anError |
			self assert: CustomerImporter invalidInputStreamErrorDescription
			       equals: anError messageText
				]! !
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:40:37' prior: 50626232!
test05notEnoughFieldsInAddress
	" CustomerImporter valueFrom: self invalidWithNotEnoughFieldsInAddressImportData into: session. "
	| aClosure |
	self assertClosureRaisesInvalidInputError: aClosure! !
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:40:49' prior: 50626256!
test05notEnoughFieldsInAddress
	
	self assertClosureRaisesInvalidInputError: [
		CustomerImporter valueFrom: self invalidWithNotEnoughFieldsInAddressImportData into: session.
		]! !

!testRun: #ImportTest #test05notEnoughFieldsInAddress stamp: 'dsf 6/26/2023 19:40:51'!
ERROR!
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:41:03' prior: 50626245!
assertClosureRaisesInvalidInputError: aClosure

	^ self should: aClosure
		raise: Error
		withExceptionDo: [ :anError |
			self assert: CustomerImporter invalidInputStreamErrorDescription
			       equals: anError messageText
				]! !

!testRun: #ImportTest #test01Import stamp: 'dsf 6/26/2023 19:41:05'!
PASSED!

!testRun: #ImportTest #test02EmptyFile stamp: 'dsf 6/26/2023 19:41:05'!
PASSED!

!testRun: #ImportTest #test03addressFirst stamp: 'dsf 6/26/2023 19:41:05'!
PASSED!

!testRun: #ImportTest #test04notEnoughFieldsInCustomer stamp: 'dsf 6/26/2023 19:41:05'!
PASSED!

!testRun: #ImportTest #test05notEnoughFieldsInAddress stamp: 'dsf 6/26/2023 19:41:05'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:41:25' prior: 50626186!
test04notEnoughFieldsInCustomer

	self assertClosureRaisesInvalidInputError: [
		CustomerImporter valueFrom: self invalidWithNotEnoughFieldsInCustomerImportData into: session.
		]
	! !

!testRun: #ImportTest #test04notEnoughFieldsInCustomer stamp: 'dsf 6/26/2023 19:41:26'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'dsf 6/26/2023 19:41:27'!
PASSED!

!testRun: #ImportTest #test02EmptyFile stamp: 'dsf 6/26/2023 19:41:27'!
PASSED!

!testRun: #ImportTest #test03addressFirst stamp: 'dsf 6/26/2023 19:41:27'!
PASSED!

!testRun: #ImportTest #test04notEnoughFieldsInCustomer stamp: 'dsf 6/26/2023 19:41:27'!
PASSED!

!testRun: #ImportTest #test05notEnoughFieldsInAddress stamp: 'dsf 6/26/2023 19:41:27'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:41:47' prior: 50626164!
test03addressFirst

	self assertClosureRaisesInvalidInputError: [
		CustomerImporter valueFrom: self addressFirstImportData into: session.
		]
		! !

!testRun: #ImportTest #test03addressFirst stamp: 'dsf 6/26/2023 19:41:48'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'dsf 6/26/2023 19:41:48'!
PASSED!

!testRun: #ImportTest #test02EmptyFile stamp: 'dsf 6/26/2023 19:41:49'!
PASSED!

!testRun: #ImportTest #test03addressFirst stamp: 'dsf 6/26/2023 19:41:49'!
PASSED!

!testRun: #ImportTest #test04notEnoughFieldsInCustomer stamp: 'dsf 6/26/2023 19:41:49'!
PASSED!

!testRun: #ImportTest #test05notEnoughFieldsInAddress stamp: 'dsf 6/26/2023 19:41:49'!
PASSED!
!ImportTest methodsFor: 'test data' stamp: 'dsf 6/26/2023 19:44:27'!
invalidWithEmptyFieldInCustomerImportData

	^ ReadStream on: 'C,Pepe,Sanchez,D,'! !
!ImportTest methodsFor: 'test data' stamp: 'dsf 6/26/2023 19:44:39' prior: 50626350!
invalidWithEmptyFieldInCustomerImportData

	^ ReadStream on: 'C,Pepe,Sanchez,,22333444'! !
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:44:56'!
test06
	
	CustomerImporter valueFrom: self invalidWithEmptyFieldInCustomerImportData into: session.
		! !

!testRun: #ImportTest #test06 stamp: 'dsf 6/26/2023 19:44:58'!
ERROR!
!ImportTest methodsFor: 'test data' stamp: 'dsf 6/26/2023 19:45:30' prior: 50626356!
invalidWithEmptyFieldInCustomerImportData

	^ ReadStream on: 'C,Pepe,Sanchez,,,,,,22333444'! !

!testRun: #ImportTest #test06 stamp: 'dsf 6/26/2023 19:45:33'!
ERROR!

!testRun: #ImportTest #test06 stamp: 'dsf 6/26/2023 19:45:33'!
ERROR!
!ImportTest methodsFor: 'test data' stamp: 'dsf 6/26/2023 19:45:54' prior: 50626370!
invalidWithEmptyFieldInCustomerImportData

	^ ReadStream on: 'C,Pepe,Sanchez,,22333444'! !
!ImportTest methodsFor: 'tests' stamp: 'dsf 6/26/2023 19:46:50'!
test06EmptyField
	
	self assertClosureRaisesInvalidInputError: [
		CustomerImporter valueFrom: self invalidWithEmptyFieldInCustomerImportData into: session.
	]	! !

!methodRemoval: ImportTest #test06 stamp: 'dsf 6/26/2023 19:46:51'!
test06
	
	CustomerImporter valueFrom: self invalidWithEmptyFieldInCustomerImportData into: session.
		!

!testRun: #ImportTest #test06EmptyField stamp: 'dsf 6/26/2023 19:46:52'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'dsf 6/26/2023 19:46:55'!
PASSED!

!testRun: #ImportTest #test02EmptyFile stamp: 'dsf 6/26/2023 19:46:55'!
PASSED!

!testRun: #ImportTest #test03addressFirst stamp: 'dsf 6/26/2023 19:46:55'!
PASSED!

!testRun: #ImportTest #test04notEnoughFieldsInCustomer stamp: 'dsf 6/26/2023 19:46:55'!
PASSED!

!testRun: #ImportTest #test05notEnoughFieldsInAddress stamp: 'dsf 6/26/2023 19:46:55'!
PASSED!

!testRun: #ImportTest #test06EmptyField stamp: 'dsf 6/26/2023 19:46:55'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:49:11'!
isCustomer: line

	^ line beginsWith: 'C'! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:49:11' prior: 50625900 overrides: 16902254!
value

	"
	self importCustomers
	"
	| line newCustomer |

	line := readStream nextLine.
	line notNil ifTrue: [ (line beginsWith: 'A') ifTrue: [ self error: self class invalidInputStreamErrorDescription ] ].
	
	[ line notNil ] whileTrue: [
		(self isCustomer: line) ifTrue: [
			newCustomer := self createCustomerObjectFromLine: line.
			session persist: newCustomer
			].
	
		(line beginsWith: 'A') ifTrue: [
			self addAddressFrom: newCustomer toCustomer: line
			].

		line := readStream nextLine.
		].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:49:32'!
isAddress: line

	^ line beginsWith: 'A'! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:49:32' prior: 50626423 overrides: 16902254!
value

	"
	self importCustomers
	"
	| line newCustomer |

	line := readStream nextLine.
	line notNil ifTrue: [ (self isAddress: line) ifTrue: [ self error: self class invalidInputStreamErrorDescription ] ].
	
	[ line notNil ] whileTrue: [
		(self isCustomer: line) ifTrue: [
			newCustomer := self createCustomerObjectFromLine: line.
			session persist: newCustomer
			].
	
		(line beginsWith: 'A') ifTrue: [
			self addAddressFrom: newCustomer toCustomer: line
			].

		line := readStream nextLine.
		].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:49:32' prior: 50626447 overrides: 16902254!
value

	"
	self importCustomers
	"
	| line newCustomer |

	line := readStream nextLine.
	line notNil ifTrue: [ (self isAddress: line) ifTrue: [ self error: self class invalidInputStreamErrorDescription ] ].
	
	[ line notNil ] whileTrue: [
		(self isCustomer: line) ifTrue: [
			newCustomer := self createCustomerObjectFromLine: line.
			session persist: newCustomer
			].
	
		(self isAddress: line) ifTrue: [
			self addAddressFrom: newCustomer toCustomer: line
			].

		line := readStream nextLine.
		].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:50:48' prior: 50626467 overrides: 16902254!
value

	"
	self importCustomers
	"
	| line |

	line := readStream nextLine.
	line notNil ifTrue: [ (self isAddress: line) ifTrue: [ self error: self class invalidInputStreamErrorDescription ] ].
	
	[ line notNil ] whileTrue: [
		(self isCustomer: line) ifTrue: [
			|newCustomer1|
			newCustomer1 := self createCustomerObjectFromLine: line.
			session persist: newCustomer1
			].
	
		(self isAddress: line) ifTrue: [
			|newCustomer1|
			self addAddressFrom: newCustomer1 toCustomer: line
			].

		line := readStream nextLine.
		].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:51:53' prior: 50626487 overrides: 16902254!
value

	"
	self importCustomers
	"
	| line |

	line := readStream nextLine.
	line notNil ifTrue: [ (self isAddress: line) ifTrue: [ self error: self class invalidInputStreamErrorDescription ] ].
	
	[ line notNil ] whileTrue: [
		self importDatafFrom: line
		].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:55:24' prior: 50626508 overrides: 16902254!
value

	"
	self importCustomers
	"
	| line newCustomer |

	line := readStream nextLine.
	line notNil ifTrue: [ (self isAddress: line) ifTrue: [ self error: self class invalidInputStreamErrorDescription ] ].
	
	[ line notNil ] whileTrue: [
		(self isCustomer: line) ifTrue: [
			newCustomer := self createCustomerObjectFromLine: line.
			session commit.
			].
		(self isAddress: line) ifTrue: [
			self addAddressFrom: line toCustomer: newCustomer.
			].
	]

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'dsf 6/26/2023 19:55:48' prior: 50626520 overrides: 16902254!
value

	"
	self importCustomers
	"
	| line newCustomer |

	line := readStream nextLine.
	line notNil ifTrue: [ (self isAddress: line) ifTrue: [ self error: self class invalidInputStreamErrorDescription ] ].
	
	[ line notNil ] whileTrue: [
		(self isCustomer: line) ifTrue: [
			newCustomer := self createCustomerObjectFromLine: line.
			session persist.
			].
		(self isAddress: line) ifTrue: [
			self addAddressFrom: line toCustomer: newCustomer.
			].
	]

	! !

----QUIT----(26 June 2023 19:56:01) CuisUniversity-5832.image priorSource: 9366758!

----End fileIn of /home/clinux01/Descargas/linux64/CustomerImporter-35.st----!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:00:17' prior: 50626820 overrides: 16902254!
value

	"
	self importCustomers
	"
	| newCustomer line |

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData records |
			records := line findTokens: $,.
	customerData := records.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:00:27' prior: 50626971 overrides: 16902254!
value

	"
	self importCustomers
	"
	| newCustomer line |

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData records |
			records := line findTokens: $,.
			customerData := records.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:01:04' prior: 50627005 overrides: 16902254!
value

	"
	self importCustomers
	"
	| newCustomer line records |

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		records := line findTokens: $,.
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := records.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := records.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := readStream nextLine. ].

	! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:01:27'!
PASSED!
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'p 6/26/2023 20:02:23' prior: 50627039 overrides: 16902254!
value

	"
	self importCustomers
	"
	| newCustomer line  |

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		records := line findTokens: $,.
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := records.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := records.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := readStream nextLine. ].

	! !

!classDefinition: #CustomerImporter category: 'CustomerImporter' stamp: 'p 6/26/2023 20:02:23'!
Object subclass: #CustomerImporter
	instanceVariableNames: 'session readStream records'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:02:30'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:08:01' prior: 50627075 overrides: 16902254!
value

	"
	self importCustomers
	"
	| newCustomer line  |

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		records := line findTokens: $,.
		(line beginsWith: 'C') ifTrue: [ newCustomer := Customer new.
			newCustomer firstName: records second.
			newCustomer lastName: records third.
			newCustomer identificationType: records fourth.
			newCustomer identificationNumber: records fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := records.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:09:51' prior: 50627119 overrides: 16902254!
value

	"
	self importCustomers
	"
	| newCustomer line  |

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		records := line findTokens: $,.
		(line beginsWith: 'C') ifTrue: [ newCustomer := Customer new.
			newCustomer firstName: records second.
			newCustomer lastName: records third.
			newCustomer identificationType: records fourth.
			newCustomer identificationNumber: records fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | newAddress |
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: records second.
			newAddress streetNumber: records third asNumber .
			newAddress town: records fourth.
			newAddress zipCode: records fifth asNumber .
			newAddress province: records sixth ].

		line := readStream nextLine. ].

	! !

!classDefinition: #CustomerImporter category: 'CustomerImporter' stamp: 'p 6/26/2023 20:10:39'!
Object subclass: #CustomerImporter
	instanceVariableNames: 'session readStream record'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'p 6/26/2023 20:10:39' prior: 50627150 overrides: 16902254!
value

	"
	self importCustomers
	"
	| newCustomer line  |

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		record := line findTokens: $,.
		(line beginsWith: 'C') ifTrue: [ newCustomer := Customer new.
			newCustomer firstName: record second.
			newCustomer lastName: record third.
			newCustomer identificationType: record fourth.
			newCustomer identificationNumber: record fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | newAddress |
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: record second.
			newAddress streetNumber: record third asNumber .
			newAddress town: record fourth.
			newAddress zipCode: record fifth asNumber .
			newAddress province: record sixth ].

		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'p 6/26/2023 20:12:32' prior: 50627188 overrides: 16902254!
value

	"
	self importCustomers
	"
	| newCustomer   |

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		record := line findTokens: $,.
		(line beginsWith: 'C') ifTrue: [ newCustomer := Customer new.
			newCustomer firstName: record second.
			newCustomer lastName: record third.
			newCustomer identificationType: record fourth.
			newCustomer identificationNumber: record fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | newAddress |
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: record second.
			newAddress streetNumber: record third asNumber .
			newAddress town: record fourth.
			newAddress zipCode: record fifth asNumber .
			newAddress province: record sixth ].

		line := readStream nextLine. ].

	! !

!classDefinition: #CustomerImporter category: 'CustomerImporter' stamp: 'p 6/26/2023 20:12:32'!
Object subclass: #CustomerImporter
	instanceVariableNames: 'session readStream record line'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:12:42'!
isCustomerRecord

	^ line beginsWith: 'C'! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:12:42' prior: 50627217 overrides: 16902254!
value

	"
	self importCustomers
	"
	| newCustomer   |

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		record := line findTokens: $,.
		(self isCustomerRecord) ifTrue: [ newCustomer := Customer new.
			newCustomer firstName: record second.
			newCustomer lastName: record third.
			newCustomer identificationType: record fourth.
			newCustomer identificationNumber: record fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | newAddress |
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: record second.
			newAddress streetNumber: record third asNumber .
			newAddress town: record fourth.
			newAddress zipCode: record fifth asNumber .
			newAddress province: record sixth ].

		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:12:52'!
isAddressRecord

	^ line beginsWith: 'A'! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:12:52' prior: 50627258 overrides: 16902254!
value

	"
	self importCustomers
	"
	| newCustomer   |

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		record := line findTokens: $,.
		(self isCustomerRecord) ifTrue: [ newCustomer := Customer new.
			newCustomer firstName: record second.
			newCustomer lastName: record third.
			newCustomer identificationType: record fourth.
			newCustomer identificationNumber: record fifth.
			session persist: newCustomer ].

		(self isAddressRecord) ifTrue: [ | newAddress |
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: record second.
			newAddress streetNumber: record third asNumber .
			newAddress town: record fourth.
			newAddress zipCode: record fifth asNumber .
			newAddress province: record sixth ].

		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'p 6/26/2023 20:13:56' prior: 50627291 overrides: 16902254!
value

	"
	self importCustomers
	"
	 

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		record := line findTokens: $,.
		(self isCustomerRecord) ifTrue: [ newCustomer := Customer new.
			newCustomer firstName: record second.
			newCustomer lastName: record third.
			newCustomer identificationType: record fourth.
			newCustomer identificationNumber: record fifth.
			session persist: newCustomer ].

		(self isAddressRecord) ifTrue: [ | newAddress |
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: record second.
			newAddress streetNumber: record third asNumber .
			newAddress town: record fourth.
			newAddress zipCode: record fifth asNumber .
			newAddress province: record sixth ].

		line := readStream nextLine. ].

	! !

!classDefinition: #CustomerImporter category: 'CustomerImporter' stamp: 'p 6/26/2023 20:13:57'!
Object subclass: #CustomerImporter
	instanceVariableNames: 'session readStream record line newCustomer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:14:01' prior: 50627320 overrides: 16902254!
value

	"
	self importCustomers
	"
	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		record := line findTokens: $,.
		(self isCustomerRecord) ifTrue: [ newCustomer := Customer new.
			newCustomer firstName: record second.
			newCustomer lastName: record third.
			newCustomer identificationType: record fourth.
			newCustomer identificationNumber: record fifth.
			session persist: newCustomer ].

		(self isAddressRecord) ifTrue: [ | newAddress |
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: record second.
			newAddress streetNumber: record third asNumber .
			newAddress town: record fourth.
			newAddress zipCode: record fifth asNumber .
			newAddress province: record sixth ].

		line := readStream nextLine. ].

	! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:14:04'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:14:39'!
createRecord

	^ record := line findTokens: $,! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:14:39' prior: 50627357 overrides: 16902254!
value

	"
	self importCustomers
	"
	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		self createRecord.
		(self isCustomerRecord) ifTrue: [ newCustomer := Customer new.
			newCustomer firstName: record second.
			newCustomer lastName: record third.
			newCustomer identificationType: record fourth.
			newCustomer identificationNumber: record fifth.
			session persist: newCustomer ].

		(self isAddressRecord) ifTrue: [ | newAddress |
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: record second.
			newAddress streetNumber: record third asNumber .
			newAddress town: record fourth.
			newAddress zipCode: record fifth asNumber .
			newAddress province: record sixth ].

		line := readStream nextLine. ].

	! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:14:43'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:15:30'!
importCustomer

	newCustomer := Customer new.
			newCustomer firstName: record second.
			newCustomer lastName: record third.
			newCustomer identificationType: record fourth.
			newCustomer identificationNumber: record fifth.
			session persist: newCustomer! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:15:30' prior: 50627392 overrides: 16902254!
value

	"
	self importCustomers
	"
	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		self createRecord.
		(self isCustomerRecord) ifTrue: [ self importCustomer ].

		(self isAddressRecord) ifTrue: [ | newAddress |
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: record second.
			newAddress streetNumber: record third asNumber .
			newAddress town: record fourth.
			newAddress zipCode: record fifth asNumber .
			newAddress province: record sixth ].

		line := readStream nextLine. ].

	! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:15:39'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:16:18'!
importAddress

	| newAddress |
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: record second.
			newAddress streetNumber: record third asNumber .
			newAddress town: record fourth.
			newAddress zipCode: record fifth asNumber .
			newAddress province: record sixth! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:16:18' prior: 50627433 overrides: 16902254!
value

	"
	self importCustomers
	"
	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		self createRecord.
		(self isCustomerRecord) ifTrue: [ self importCustomer ].

		(self isAddressRecord) ifTrue: [ self importAddress ].

		line := readStream nextLine. ].

	! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:16:24'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:16:31' prior: 50627421!
importCustomer

	newCustomer := Customer new.
	newCustomer firstName: record second.
	newCustomer lastName: record third.
	newCustomer identificationType: record fourth.
	newCustomer identificationNumber: record fifth.
	session persist: newCustomer! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:16:34' prior: 50627483!
importCustomer

	newCustomer := Customer new.
	newCustomer firstName: record second.
	newCustomer lastName: record third.
	newCustomer identificationType: record fourth.
	newCustomer identificationNumber: record fifth.
	session persist: newCustomer.! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:16:48' prior: 50627455!
importAddress

	| newAddress |
	
	newAddress := Address new.
	newCustomer addAddress: newAddress.
	newAddress streetName: record second.
	newAddress streetNumber: record third asNumber .
	newAddress town: record fourth.
	newAddress zipCode: record fifth asNumber.
	newAddress province: record sixth.! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:17:12'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:18:00' prior: 50627469 overrides: 16902254!
value

	"
	self importCustomers
	"
	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		self createRecord.
		(self isCustomerRecord) ifTrue: [ self importCustomer ].
		(self isAddressRecord) ifTrue: [ self importAddress ].

		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:18:06'!
importRecord

	(self isCustomerRecord) ifTrue: [ self importCustomer ].
		(self isAddressRecord) ifTrue: [ self importAddress ]! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:18:06' prior: 50627521 overrides: 16902254!
value

	"
	self importCustomers
	"
	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		self createRecord.
		self importRecord.

		line := readStream nextLine. ].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:18:09' prior: 50627540 overrides: 16902254!
value

	"
	self importCustomers
	"
	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		self createRecord.
		self importRecord.
		line := readStream nextLine. ].

	! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:18:10'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:19:50' prior: 50627549 overrides: 16902254!
value

	"
	self importCustomers
	"
	[ line := readStream nextLine.
	  line notNil ] whileTrue: [
		self createRecord.
		self importRecord.
		].

	! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:19:51'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:21:45'!
hasLinesLeft

	line := readStream nextLine.
	  line notNil! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:21:45' prior: 50627561 overrides: 16902254!
value

	"
	self importCustomers
	"
	[ self hasLinesLeft ] whileTrue: [
		self createRecord.
		self importRecord.
		].

	! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:21:50'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:21:50'!
ERROR!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:22:15' prior: 50627571!
hasLinesLeft

	line := readStream nextLine.
	^ line notNil.
	! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:22:19'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:22:35' prior: 50627577 overrides: 16902254!
value

	[ self hasLinesLeft ] whileTrue: [
		self createRecord.
		self importRecord.
		].

	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:23:56' prior: 50627532!
importRecord

	(self isCustomerRecord) ifTrue: [ self importCustomer ].
	(self isAddressRecord) ifTrue: [ self importAddress ].! !
!ImportTest methodsFor: 'test data' stamp: 'p 6/26/2023 20:36:06'!
EmptyImportData

	^ ReadStream on: ''! !
!ImportTest methodsFor: 'test data' stamp: 'p 6/26/2023 20:36:17'!
emptyImportData

	^ ReadStream on: ''! !

!methodRemoval: ImportTest #EmptyImportData stamp: 'p 6/26/2023 20:36:17'!
EmptyImportData

	^ ReadStream on: ''!
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 20:36:32'!
test02Empty

	CustomerImporter valueFrom: self emptyImportData into: session.
! !

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 20:36:33'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:36:34'!
PASSED!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 20:36:34'!
PASSED!
!ImportTest methodsFor: 'test data' stamp: 'p 6/26/2023 20:37:40'!
importDataWithNotEnoughCustomerFields

	^ ReadStream on: 'C,Pepe,Sanchez,D'! !
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 20:37:58'!
test03notEnoughCustomerFields

	CustomerImporter valueFrom: self importDataWithNotEnoughCustomerFields into: session.
! !

!testRun: #ImportTest #test03notEnoughCustomerFields stamp: 'p 6/26/2023 20:37:59'!
ERROR!
!CustomerImporter methodsFor: 'initialization' stamp: 'p 6/26/2023 20:38:13' prior: 50626814!
initializeFrom: aReadStream into: aSession

	session := aSession.
	readStream := aReadStream.! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:41:22' prior: 50627603!
importRecord

	(self isCustomerRecord) ifTrue: [ 
		self raiseErrorIfRecordSizeIsNotCorrectForCustomer.
		self importCustomer ].
	(self isAddressRecord) ifTrue: [ self importAddress ].! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:41:48'!
raiseErrorIfRecordSizeIsNotCorrectForCustomer

	self error: self class invalidInputErrorDescription.
		! !
!CustomerImporter class methodsFor: 'importing' stamp: 'p 6/26/2023 20:42:12'!
invalidInputErrorDescription

	^ 'Invalid input'.! !
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 20:44:01' prior: 50627638!
test03notEnoughCustomerFields

	self should: [ 	CustomerImporter valueFrom: self importDataWithNotEnoughCustomerFields into: session. ]
	raise: Error
	withExceptionDo: [ :anError |
		self assert: CustomerImporter invalidInputErrorDescription
		      equals: anError messageText.
		].
! !

!testRun: #ImportTest #test03notEnoughCustomerFields stamp: 'p 6/26/2023 20:44:02'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:44:02'!
ERROR!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 20:44:02'!
PASSED!

!testRun: #ImportTest #test03notEnoughCustomerFields stamp: 'p 6/26/2023 20:44:02'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:44:02'!
ERROR!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 20:44:08'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:44:10'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:44:10'!
ERROR!
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 20:44:18' prior: 50626569!
test01Import

	CustomerImporter valueFrom: self validImportData into: session.

	self assertImportedRightNumberOfCustomers.
	self assertPepeSanchezWasImportedCorrecty.
	self assertJuanPerezWasImportedCorrectly ! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:44:19'!
ERROR!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:45:16' prior: 50627663!
raiseErrorIfRecordSizeIsNotCorrectForCustomer
	
	(record size = 5) ifFalse: [
		self error: self class invalidInputErrorDescription.
		]
		! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:45:30'!
raiseErrorIfRecordSizeIsNotCorrectForCustomer: recordSize
	
	(record size = 5) ifFalse: [
		self error: self class invalidInputErrorDescription.
		]
		! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'p 6/26/2023 20:45:30' prior: 50627654!
importRecord

	(self isCustomerRecord) ifTrue: [ 
		self raiseErrorIfRecordSizeIsNotCorrectForCustomer: 5.
		self importCustomer ].
	(self isAddressRecord) ifTrue: [ self importAddress ].! !

!methodRemoval: CustomerImporter #raiseErrorIfRecordSizeIsNotCorrectForCustomer stamp: 'p 6/26/2023 20:45:30'!
raiseErrorIfRecordSizeIsNotCorrectForCustomer
	
	(record size = 5) ifFalse: [
		self error: self class invalidInputErrorDescription.
		]
		!
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'p 6/26/2023 20:45:30' prior: 50627725!
raiseErrorIfRecordSizeIsNotCorrectForCustomer: recordSize
	
	(record size = recordSize) ifFalse: [
		self error: self class invalidInputErrorDescription.
		]
		! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:45:46'!
raiseErrorIfRecordSizeIsNot: recordSize
	
	(record size = recordSize) ifFalse: [
		self error: self class invalidInputErrorDescription.
		]
		! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'p 6/26/2023 20:45:46' prior: 50627733!
importRecord

	(self isCustomerRecord) ifTrue: [ 
		self raiseErrorIfRecordSizeIsNot: 5.
		self importCustomer ].
	(self isAddressRecord) ifTrue: [ self importAddress ].! !

!methodRemoval: CustomerImporter #raiseErrorIfRecordSizeIsNotCorrectForCustomer: stamp: 'p 6/26/2023 20:45:46'!
raiseErrorIfRecordSizeIsNotCorrectForCustomer: recordSize
	
	(record size = recordSize) ifFalse: [
		self error: self class invalidInputErrorDescription.
		]
		!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:46:02' prior: 50627766!
importRecord

	(self isCustomerRecord) ifTrue: [ 
		self raiseErrorIfRecordSizeIsNot: 5.
		self importCustomer ].
	(self isAddressRecord) ifTrue: [ 
		self importAddress ].! !
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 20:46:25'!
test04notEnoughAddressFields

	self should: [ 	CustomerImporter valueFrom: self importDataWithNotEnoughAddressFields into: session. ]
	raise: Error
	withExceptionDo: [ :anError |
		self assert: CustomerImporter invalidInputErrorDescription
		      equals: anError messageText.
		].
! !
!ImportTest methodsFor: 'test data' stamp: 'p 6/26/2023 20:46:40'!
importDataWithNotEnoughAddressFields

	^ ReadStream on:
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636'! !

!testRun: #ImportTest #test04notEnoughAddressFields stamp: 'p 6/26/2023 20:46:44'!
FAILURE!

!testRun: #ImportTest #test04notEnoughAddressFields stamp: 'p 6/26/2023 20:46:44'!
FAILURE!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 20:47:04' prior: 50627783!
importRecord

	(self isCustomerRecord) ifTrue: [ 
		self raiseErrorIfRecordSizeIsNot: 5.
		self importCustomer ].
	(self isAddressRecord) ifTrue: [
		self raiseErrorIfRecordSizeIsNot: 6. 
		self importAddress ].! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:47:06'!
PASSED!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 20:47:06'!
PASSED!

!testRun: #ImportTest #test03notEnoughCustomerFields stamp: 'p 6/26/2023 20:47:06'!
PASSED!

!testRun: #ImportTest #test04notEnoughAddressFields stamp: 'p 6/26/2023 20:47:06'!
PASSED!
!ImportTest methodsFor: 'test data' stamp: 'p 6/26/2023 20:47:20'!
importDataWithAddressBeforeCustomer

	^ ReadStream on: 'C,Pepe,Sanchez,D'! !
!ImportTest methodsFor: 'test data' stamp: 'p 6/26/2023 20:47:33' prior: 50627836!
importDataWithAddressBeforeCustomer

	^ ReadStream on: 'A,San Martin,3322,Olivos,1636'! !
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 20:47:54'!
test05

	self should: [ 	CustomerImporter valueFrom: self importDataWithAddressBeforeCustomer into: session. ]
	raise: Error
	withExceptionDo: [ :anError |
		self assert: CustomerImporter invalidInputErrorDescription
		      equals: anError messageText.
		].
! !

!testRun: #ImportTest #test05 stamp: 'p 6/26/2023 20:47:56'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:47:56'!
PASSED!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 20:47:56'!
PASSED!

!testRun: #ImportTest #test03notEnoughCustomerFields stamp: 'p 6/26/2023 20:47:56'!
PASSED!

!testRun: #ImportTest #test04notEnoughAddressFields stamp: 'p 6/26/2023 20:47:57'!
PASSED!

!testRun: #ImportTest #test05 stamp: 'p 6/26/2023 20:47:57'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 20:48:36'!
test05addressBeforeCustomer

	self should: [ 	CustomerImporter valueFrom: self importDataWithAddressBeforeCustomer into: session. ]
	raise: Error
	withExceptionDo: [ :anError |
		self assert: CustomerImporter invalidInputErrorDescription
		      equals: anError messageText.
		].
! !

!methodRemoval: ImportTest #test05 stamp: 'p 6/26/2023 20:48:36'!
test05

	self should: [ 	CustomerImporter valueFrom: self importDataWithAddressBeforeCustomer into: session. ]
	raise: Error
	withExceptionDo: [ :anError |
		self assert: CustomerImporter invalidInputErrorDescription
		      equals: anError messageText.
		].
!

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:48:41'!
PASSED!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 20:48:41'!
PASSED!

!testRun: #ImportTest #test03notEnoughCustomerFields stamp: 'p 6/26/2023 20:48:41'!
PASSED!

!testRun: #ImportTest #test04notEnoughAddressFields stamp: 'p 6/26/2023 20:48:42'!
PASSED!

!testRun: #ImportTest #test05addressBeforeCustomer stamp: 'p 6/26/2023 20:48:42'!
PASSED!
!CustomerImporter class methodsFor: 'instance creation' stamp: 'p 6/26/2023 20:50:27' prior: 50626861!
from: aReadStream into: aSession
	^ self new initializeFrom: aReadStream into: aSession! !
!CustomerImporter class methodsFor: 'instance creation' stamp: 'p 6/26/2023 20:50:50' prior: 50627908!
from: aReadStream into: aSession
	
	aReadStream ifEmpty: [ self invalidInputErrorDescription ].
	^ self new initializeFrom: aReadStream into: aSession! !
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 20:51:52' prior: 50627621!
test02Empty

	self should: [ 	CustomerImporter valueFrom: self emptyImportData into: session. ]
	raise: Error
	withExceptionDo: [ :anError |
		self assert: CustomerImporter invalidInputErrorDescription
		      equals: anError messageText.
		].
	
! !
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 20:52:08' prior: 50627923!
test02Empty
	" CustomerImporter valueFrom: self emptyImportData into: session. "
	self should: [ 	 ]
	raise: Error
	withExceptionDo: [ :anError |
		self assert: CustomerImporter invalidInputErrorDescription
		      equals: anError messageText.
		].
	
! !
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 20:52:36'!
assertInvalidInputErrorIsRaisedBy

	^ self should: [ 	 ]
	raise: Error
	withExceptionDo: [ :anError |
		self assert: CustomerImporter invalidInputErrorDescription
		      equals: anError messageText.
		]! !
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 20:52:36' prior: 50627934!
test02Empty
	" CustomerImporter valueFrom: self emptyImportData into: session. "
	self assertInvalidInputErrorIsRaisedBy.
	
! !
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 20:52:47'!
assertInvalidInputErrorIsRaisedBy: aClosure

	^ self should: aClosure
	raise: Error
	withExceptionDo: [ :anError |
		self assert: CustomerImporter invalidInputErrorDescription
		      equals: anError messageText.
		]! !

!methodRemoval: ImportTest #assertInvalidInputErrorIsRaisedBy stamp: 'p 6/26/2023 20:52:51'!
assertInvalidInputErrorIsRaisedBy

	^ self should: [ 	 ]
	raise: Error
	withExceptionDo: [ :anError |
		self assert: CustomerImporter invalidInputErrorDescription
		      equals: anError messageText.
		]!
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 20:53:12' prior: 50627953!
test02Empty

	self assertInvalidInputErrorIsRaisedBy: [
		CustomerImporter valueFrom: self emptyImportData into: session.	
		].
	
! !

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 20:53:13'!
FAILURE!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 20:53:13'!
FAILURE!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 20:53:22'!
FAILURE!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 20:53:22'!
FAILURE!
!CustomerImporter class methodsFor: 'instance creation' stamp: 'p 6/26/2023 20:53:38' prior: 50627915!
from: aReadStream into: aSession
	
	aReadStream ifEmpty: [ self error: self invalidInputErrorDescription ].
	^ self new initializeFrom: aReadStream into: aSession! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:53:40'!
ERROR!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 20:53:40'!
FAILURE!

!testRun: #ImportTest #test03notEnoughCustomerFields stamp: 'p 6/26/2023 20:53:40'!
FAILURE!

!testRun: #ImportTest #test04notEnoughAddressFields stamp: 'p 6/26/2023 20:53:40'!
FAILURE!

!testRun: #ImportTest #test05addressBeforeCustomer stamp: 'p 6/26/2023 20:53:40'!
FAILURE!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 20:53:45'!
FAILURE!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 20:53:46'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 20:54:54' prior: 50627959!
assertInvalidInputErrorIsRaisedBy: aClosure

	^ self should: aClosure value
	raise: Error
	withExceptionDo: [ :anError |
		self assert: CustomerImporter invalidInputErrorDescription
		      equals: anError messageText.
		]! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:54:56'!
ERROR!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 20:54:56'!
ERROR!

!testRun: #ImportTest #test03notEnoughCustomerFields stamp: 'p 6/26/2023 20:54:56'!
FAILURE!

!testRun: #ImportTest #test04notEnoughAddressFields stamp: 'p 6/26/2023 20:54:56'!
FAILURE!

!testRun: #ImportTest #test05addressBeforeCustomer stamp: 'p 6/26/2023 20:54:56'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 20:55:01' prior: 50628021!
assertInvalidInputErrorIsRaisedBy: aClosure

	^ self should: aClosure
	raise: Error
	withExceptionDo: [ :anError |
		self assert: CustomerImporter invalidInputErrorDescription
		      equals: anError messageText.
		]! !

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 20:55:21'!
FAILURE!
!CustomerImporter class methodsFor: 'instance creation' stamp: 'p 6/26/2023 20:56:03' prior: 50627995!
from: aReadStream into: aSession
	
	(aReadStream isEmpty) ifTrue: [ self error: self invalidInputErrorDescription ].
	^ self new initializeFrom: aReadStream into: aSession! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:56:06'!
PASSED!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 20:56:07'!
PASSED!

!testRun: #ImportTest #test03notEnoughCustomerFields stamp: 'p 6/26/2023 20:56:07'!
PASSED!

!testRun: #ImportTest #test04notEnoughAddressFields stamp: 'p 6/26/2023 20:56:07'!
PASSED!

!testRun: #ImportTest #test05addressBeforeCustomer stamp: 'p 6/26/2023 20:56:07'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 20:56:50'!
PASSED!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 20:56:50'!
PASSED!

!testRun: #ImportTest #test03notEnoughCustomerFields stamp: 'p 6/26/2023 20:56:50'!
PASSED!

!testRun: #ImportTest #test04notEnoughAddressFields stamp: 'p 6/26/2023 20:56:51'!
PASSED!

!testRun: #ImportTest #test05addressBeforeCustomer stamp: 'p 6/26/2023 20:56:51'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 20:57:57'!
assert: aClosure raises: anError

	^ self should: aClosure
	raise: Error
	withExceptionDo: [
		self assert: CustomerImporter invalidInputErrorDescription
		      equals: anError messageText.
		]! !
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 20:58:54' prior: 50627978!
test02Empty

	self assert: [ CustomerImporter valueFrom: self emptyImportData into: session ]
	      raises: CustomerImporter emptyStreamErrorDescription.
	
! !
!CustomerImporter class methodsFor: 'importing' stamp: 'p 6/26/2023 20:59:13'!
emptyStreamErrorDescription

	^ 'Stream is empty >:('.! !
!CustomerImporter class methodsFor: 'instance creation' stamp: 'p 6/26/2023 20:59:37' prior: 50628057!
from: aReadStream into: aSession
	
	(aReadStream isEmpty) ifTrue: [ self error: self emptyStreamErrorDescription ].
	^ self new initializeFrom: aReadStream into: aSession! !

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 21:00:24'!
ERROR!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 21:00:24'!
ERROR!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 21:00:34'!
ERROR!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 21:00:34'!
ERROR!
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 21:01:13' prior: 50628092!
assert: aClosure raises: anError

	^ self should: aClosure
		  raise: Error
		  withExceptionDo: [
			  self assert: CustomerImporter invalidInputErrorDescription
			        equals: anError.
			  ]! !
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 21:01:40' prior: 50628044!
assertInvalidInputErrorIsRaisedBy: aClosure

	^ self should: aClosure
		raise: Error
		withExceptionDo: [ :anError |
			self assert: CustomerImporter invalidInputErrorDescription
			      equals: anError messageText.
			]! !
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 21:02:47' prior: 50628133!
assert: aClosure raises: expectedError

	^ self should: aClosure
		  raise: Error
		  withExceptionDo: [ :anError |
			  self assert: expectedError
			        equals: anError.
			  ]! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 21:02:49'!
PASSED!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 21:02:49'!
FAILURE!

!testRun: #ImportTest #test03notEnoughCustomerFields stamp: 'p 6/26/2023 21:02:49'!
PASSED!

!testRun: #ImportTest #test04notEnoughAddressFields stamp: 'p 6/26/2023 21:02:49'!
PASSED!

!testRun: #ImportTest #test05addressBeforeCustomer stamp: 'p 6/26/2023 21:02:49'!
PASSED!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 21:02:49'!
FAILURE!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 21:02:52'!
FAILURE!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 21:02:52'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 21:03:08' prior: 50628152!
assert: aClosure raises: expectedError

	^ self should: aClosure
		  raise: Error
		  withExceptionDo: [ :anError |
			  self assert: expectedError
			        equals: anError messageText.
			  ]! !

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 21:03:10'!
PASSED!

!methodRemoval: ImportTest #assertInvalidInputErrorIsRaisedBy: stamp: 'p 6/26/2023 21:03:13'!
assertInvalidInputErrorIsRaisedBy: aClosure

	^ self should: aClosure
		raise: Error
		withExceptionDo: [ :anError |
			self assert: CustomerImporter invalidInputErrorDescription
			      equals: anError messageText.
			]!
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 21:03:58' prior: 50627674!
test03notEnoughCustomerFields

	self assert: [ CustomerImporter valueFrom: self importDataWithNotEnoughCustomerFields into: session. ]
	      raises: CustomerImporter customerWithNotEnoughFieldsErrorDescription.
! !
!CustomerImporter class methodsFor: 'importing' stamp: 'p 6/26/2023 21:04:35'!
customerWithNotEnoughFieldsErrorDescription

	^ 'Found customer line with not enough fields >:('.! !
!CustomerImporter class methodsFor: 'importing' stamp: 'p 6/26/2023 21:05:37'!
lineWithNotEnoughFieldsErrorDescription

	^ 'Found line with not enough fields >:('.! !

!methodRemoval: CustomerImporter class #customerWithNotEnoughFieldsErrorDescription stamp: 'p 6/26/2023 21:05:39'!
customerWithNotEnoughFieldsErrorDescription

	^ 'Found customer line with not enough fields >:('.!
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 21:05:52' prior: 50628202!
test03notEnoughCustomerFields

	self assert: [ CustomerImporter valueFrom: self importDataWithNotEnoughCustomerFields into: session. ]
	      raises: CustomerImporter lineWithNotEnoughFieldsErrorDescription.
! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 21:06:01' prior: 50627758!
raiseErrorIfRecordSizeIsNot: recordSize
	
	(record size = recordSize) ifFalse: [
		self error: self class lineWithNotEnoughFieldsErrorDescription.
		]
		! !

!testRun: #ImportTest #test03notEnoughCustomerFields stamp: 'p 6/26/2023 21:06:05'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 21:06:47' prior: 50627791!
test04notEnoughAddressFields

	self assert: [ CustomerImporter valueFrom: self importDataWithNotEnoughAddressFields into: session. ]
	      raises: CustomerImporter lineWithNotEnoughFieldsErrorDescription.! !

!testRun: #ImportTest #test04notEnoughAddressFields stamp: 'p 6/26/2023 21:06:48'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 21:10:40' prior: 50628251!
test04notEnoughAddressFields

	self assert: [ CustomerImporter valueFrom: self importDataWithNotEnoughAddressFields into: session. ]
	       raises: CustomerImporter lineWithNotEnoughFieldsErrorDescription.! !
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 21:10:42' prior: 50628230!
test03notEnoughCustomerFields

	self assert: [ CustomerImporter valueFrom: self importDataWithNotEnoughCustomerFields into: session. ]
	       raises: CustomerImporter lineWithNotEnoughFieldsErrorDescription.
! !
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 21:10:45' prior: 50628101!
test02Empty

	self assert: [ CustomerImporter valueFrom: self emptyImportData into: session ]
	       raises: CustomerImporter emptyStreamErrorDescription.
	
! !
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 21:11:40' prior: 50627872!
test05addressBeforeCustomer
	
	self assert: [ CustomerImporter valueFrom: self importDataWithAddressBeforeCustomer into: session. ]
	       raises: CustomerImporter addressBeforeCustomerErrorDescription.
! !

!methodRemoval: CustomerImporter class #invalidInputErrorDescription stamp: 'p 6/26/2023 21:11:49'!
invalidInputErrorDescription

	^ 'Invalid input'.!
!CustomerImporter class methodsFor: 'importing' stamp: 'p 6/26/2023 21:12:17'!
addressBeforeCustomerErrorDescription

	^ 'Found an address before a customer >:('.! !

!testRun: #ImportTest #test05addressBeforeCustomer stamp: 'p 6/26/2023 21:13:28'!
FAILURE!

!testRun: #ImportTest #test05addressBeforeCustomer stamp: 'p 6/26/2023 21:13:28'!
FAILURE!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 21:14:25' prior: 50627816!
importRecord

	(self isCustomerRecord) ifTrue: [ 
		self raiseErrorIfRecordSizeIsNot: 5.
		self importCustomer ].
	(self isAddressRecord) ifTrue: [
		self raiseErrorIfAddressFoundBeforeCustomer.
		self raiseErrorIfRecordSizeIsNot: 6. 
		self importAddress ].! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 21:14:54'!
raiseErrorIfAddressFoundBeforeCustomer

	newCustomer ifNil: [
		self error: self class addressBeforeCustomerErrorDescription 
		].! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 21:14:57'!
PASSED!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 21:14:57'!
PASSED!

!testRun: #ImportTest #test03notEnoughCustomerFields stamp: 'p 6/26/2023 21:14:57'!
PASSED!

!testRun: #ImportTest #test04notEnoughAddressFields stamp: 'p 6/26/2023 21:14:57'!
PASSED!

!testRun: #ImportTest #test05addressBeforeCustomer stamp: 'p 6/26/2023 21:14:57'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 21:15:40'!
test03notEnoughOrMoreCustomerFields

	self assert: [ CustomerImporter valueFrom: self importDataWithNotEnoughCustomerFields into: session. ]
	       raises: CustomerImporter lineWithNotEnoughFieldsErrorDescription.
! !

!methodRemoval: ImportTest #test03notEnoughCustomerFields stamp: 'p 6/26/2023 21:15:41'!
test03notEnoughCustomerFields

	self assert: [ CustomerImporter valueFrom: self importDataWithNotEnoughCustomerFields into: session. ]
	       raises: CustomerImporter lineWithNotEnoughFieldsErrorDescription.
!
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 21:15:48'!
test04notEnoughOrMoreAddressFields

	self assert: [ CustomerImporter valueFrom: self importDataWithNotEnoughAddressFields into: session. ]
	       raises: CustomerImporter lineWithNotEnoughFieldsErrorDescription.! !

!methodRemoval: ImportTest #test04notEnoughAddressFields stamp: 'p 6/26/2023 21:15:48'!
test04notEnoughAddressFields

	self assert: [ CustomerImporter valueFrom: self importDataWithNotEnoughAddressFields into: session. ]
	       raises: CustomerImporter lineWithNotEnoughFieldsErrorDescription.!
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 21:16:22'!
test06IsNotCustomerNorAddress
	
	self assert: [ CustomerImporter valueFrom: self importDataWithAddressBeforeCustomer into: session. ]
	       raises: CustomerImporter notACustomerNorAnAddressErrorDescription.
! !
!CustomerImporter class methodsFor: 'importing' stamp: 'p 6/26/2023 21:16:37'!
notACustomerNorAnAddressErrorDescription

	^ 'Found line with not a customer nor an address >:('.! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 21:17:26' prior: 50628317!
importRecord

	self raiseErrorIfItsNotACustomerNorAnAddress.
	(self isCustomerRecord) ifTrue: [ 
		self raiseErrorIfRecordSizeIsNot: 5.
		self importCustomer ].
	(self isAddressRecord) ifTrue: [
		self raiseErrorIfAddressFoundBeforeCustomer.
		self raiseErrorIfRecordSizeIsNot: 6. 
		self importAddress ].! !
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 21:18:19' prior: 50628385!
test06IsNotCustomerNorAddress
	
	self assert: [ CustomerImporter valueFrom: self importDataWithNotACustomerNorAnAddress into: session. ]
	       raises: CustomerImporter notACustomerNorAnAddressErrorDescription.
! !
!ImportTest methodsFor: 'test data' stamp: 'p 6/26/2023 21:18:38'!
importDataWithNotACustomerNorAnAddress

	^ ReadStream on: 'X,Pepe,Sanchez,D,22333444'! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 21:19:55'!
raiseErrorIfItsNotACustomerNorAnAddress

	(record first = 'C' or: record first = 'A') ifFalse: [
		self error: self class notACustomerNorAnAddressErrorDescription
		].! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 21:19:58'!
PASSED!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 21:19:59'!
PASSED!

!testRun: #ImportTest #test03notEnoughOrMoreCustomerFields stamp: 'p 6/26/2023 21:19:59'!
PASSED!

!testRun: #ImportTest #test04notEnoughOrMoreAddressFields stamp: 'p 6/26/2023 21:19:59'!
PASSED!

!testRun: #ImportTest #test05addressBeforeCustomer stamp: 'p 6/26/2023 21:19:59'!
PASSED!

!testRun: #ImportTest #test06IsNotCustomerNorAddress stamp: 'p 6/26/2023 21:19:59'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 21:21:07'!
test07adjacentCommas
	
	self assert: [ CustomerImporter valueFrom: self importDataWithAdjacentCommas into: session. ]
	       raises: CustomerImporter adjacentCommasErrorDescription.
! !
!ImportTest methodsFor: 'test data' stamp: 'p 6/26/2023 21:21:37'!
importDataWithAdjacentCommas

	^ ReadStream on: 'C,Pepe,Sanchez,D,,22333444'! !
!CustomerImporter class methodsFor: 'importing' stamp: 'p 6/26/2023 21:22:15'!
adjacentCommasErrorDescription

	^ 'Found line with adjacent commas >:('.! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 21:25:12' prior: 50627387!
createRecord

	record := line findTokens: $,.
	((line occurrencesOf: $,) = (record size - 1)) ifFalse: [
		self error: self class adjacentCommasErrorDescription
		].
	^ record! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 21:25:22'!
raiseErrorIfAdjacentCommas

	^ ((line occurrencesOf: $,) = (record size - 1)) ifFalse: [
		self error: self class adjacentCommasErrorDescription
		]! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 21:25:22' prior: 50628472!
createRecord

	record := line findTokens: $,.
	self raiseErrorIfAdjacentCommas.
	^ record! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 21:25:26'!
PASSED!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 21:25:26'!
PASSED!

!testRun: #ImportTest #test03notEnoughOrMoreCustomerFields stamp: 'p 6/26/2023 21:25:26'!
PASSED!

!testRun: #ImportTest #test04notEnoughOrMoreAddressFields stamp: 'p 6/26/2023 21:25:26'!
PASSED!

!testRun: #ImportTest #test05addressBeforeCustomer stamp: 'p 6/26/2023 21:25:26'!
PASSED!

!testRun: #ImportTest #test06IsNotCustomerNorAddress stamp: 'p 6/26/2023 21:25:26'!
PASSED!

!testRun: #ImportTest #test07adjacentCommas stamp: 'p 6/26/2023 21:25:26'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 21:25:41' prior: 50628480!
raiseErrorIfAdjacentCommas

	^ (line occurrencesOf: $, = (record size - 1)) ifFalse: [
		self error: self class adjacentCommasErrorDescription
		]! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 21:25:42'!
ERROR!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 21:25:42'!
PASSED!

!testRun: #ImportTest #test03notEnoughOrMoreCustomerFields stamp: 'p 6/26/2023 21:25:42'!
FAILURE!

!testRun: #ImportTest #test04notEnoughOrMoreAddressFields stamp: 'p 6/26/2023 21:25:42'!
FAILURE!

!testRun: #ImportTest #test05addressBeforeCustomer stamp: 'p 6/26/2023 21:25:42'!
FAILURE!

!testRun: #ImportTest #test06IsNotCustomerNorAddress stamp: 'p 6/26/2023 21:25:42'!
FAILURE!

!testRun: #ImportTest #test07adjacentCommas stamp: 'p 6/26/2023 21:25:42'!
FAILURE!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 21:25:56' prior: 50628513!
raiseErrorIfAdjacentCommas

	^ ((line occurrencesOf: $,) = record size - 1) ifFalse: [
		self error: self class adjacentCommasErrorDescription
		]! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 21:25:57'!
ERROR!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 21:25:57'!
PASSED!

!testRun: #ImportTest #test03notEnoughOrMoreCustomerFields stamp: 'p 6/26/2023 21:25:57'!
FAILURE!

!testRun: #ImportTest #test04notEnoughOrMoreAddressFields stamp: 'p 6/26/2023 21:25:57'!
FAILURE!

!testRun: #ImportTest #test05addressBeforeCustomer stamp: 'p 6/26/2023 21:25:57'!
FAILURE!

!testRun: #ImportTest #test06IsNotCustomerNorAddress stamp: 'p 6/26/2023 21:25:57'!
FAILURE!

!testRun: #ImportTest #test07adjacentCommas stamp: 'p 6/26/2023 21:25:57'!
FAILURE!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 21:26:05' prior: 50628540!
raiseErrorIfAdjacentCommas

	^ ((line occurrencesOf: $,) = (record size - 1)) ifFalse: [
		self error: self class adjacentCommasErrorDescription
		]! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 21:26:07'!
PASSED!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 21:26:07'!
PASSED!

!testRun: #ImportTest #test03notEnoughOrMoreCustomerFields stamp: 'p 6/26/2023 21:26:07'!
PASSED!

!testRun: #ImportTest #test04notEnoughOrMoreAddressFields stamp: 'p 6/26/2023 21:26:07'!
PASSED!

!testRun: #ImportTest #test05addressBeforeCustomer stamp: 'p 6/26/2023 21:26:07'!
PASSED!

!testRun: #ImportTest #test06IsNotCustomerNorAddress stamp: 'p 6/26/2023 21:26:07'!
PASSED!

!testRun: #ImportTest #test07adjacentCommas stamp: 'p 6/26/2023 21:26:07'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 21:34:54' prior: 50628401!
importRecord

	(self isCustomerRecord) ifTrue: [ 
		self raiseErrorIfRecordSizeIsNot: 5.
		self importCustomer.
		^ self ].
	(self isAddressRecord) ifTrue: [
		self raiseErrorIfAddressFoundBeforeCustomer.
		self raiseErrorIfRecordSizeIsNot: 6. 
		self importAddress.
		^ self ].
	self raiseInvalidEntryType.! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 21:35:11' prior: 50628594!
importRecord

	(self isCustomerRecord) ifTrue: [ 
		self raiseErrorIfRecordSizeIsNot: 5.
		self importCustomer.
		^ self ].
	(self isAddressRecord) ifTrue: [
		self raiseErrorIfAddressFoundBeforeCustomer.
		self raiseErrorIfRecordSizeIsNot: 6. 
		self importAddress.
		^ self ].
	self raiseInvalidEntryTypeError.! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 21:35:27'!
raiseInvalidEntryTypeError

	self error: self class invalidEntryTypeRecord.! !

!methodRemoval: CustomerImporter #raiseErrorIfItsNotACustomerNorAnAddress stamp: 'p 6/26/2023 21:35:31'!
raiseErrorIfItsNotACustomerNorAnAddress

	(record first = 'C' or: record first = 'A') ifFalse: [
		self error: self class notACustomerNorAnAddressErrorDescription
		].!
!CustomerImporter class methodsFor: 'importing' stamp: 'p 6/26/2023 21:37:07' prior: 50628395!
notACustomerNorAnAddressErrorDescription

	^ 'Found line with invalid type of entry >:('.! !
!CustomerImporter class methodsFor: 'importing' stamp: 'p 6/26/2023 21:37:54'!
notEnoughFieldsErrorDescription

	^ 'Found line with not enough fields >:('.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'p 6/26/2023 21:37:54' prior: 50628348!
test03notEnoughOrMoreCustomerFields

	self assert: [ CustomerImporter valueFrom: self importDataWithNotEnoughCustomerFields into: session. ]
	       raises: CustomerImporter notEnoughFieldsErrorDescription.
! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'p 6/26/2023 21:37:54' prior: 50628240!
raiseErrorIfRecordSizeIsNot: recordSize
	
	(record size = recordSize) ifFalse: [
		self error: self class notEnoughFieldsErrorDescription.
		]
		! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'p 6/26/2023 21:37:54' prior: 50628367!
test04notEnoughOrMoreAddressFields

	self assert: [ CustomerImporter valueFrom: self importDataWithNotEnoughAddressFields into: session. ]
	       raises: CustomerImporter notEnoughFieldsErrorDescription.! !

!methodRemoval: CustomerImporter class #lineWithNotEnoughFieldsErrorDescription stamp: 'p 6/26/2023 21:37:54'!
lineWithNotEnoughFieldsErrorDescription

	^ 'Found line with not enough fields >:('.!
!CustomerImporter class methodsFor: 'importing' stamp: 'p 6/26/2023 21:38:31'!
invalidTypeOfEntryErrorDescription

	^ 'Found line with invalid type of entry >:('.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'p 6/26/2023 21:38:31' prior: 50628414!
test06IsNotCustomerNorAddress
	
	self assert: [ CustomerImporter valueFrom: self importDataWithNotACustomerNorAnAddress into: session. ]
	       raises: CustomerImporter invalidTypeOfEntryErrorDescription.
! !

!methodRemoval: CustomerImporter class #notACustomerNorAnAddressErrorDescription stamp: 'p 6/26/2023 21:38:31'!
notACustomerNorAnAddressErrorDescription

	^ 'Found line with invalid type of entry >:('.!

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 21:38:39'!
PASSED!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 21:38:39'!
PASSED!

!testRun: #ImportTest #test03notEnoughOrMoreCustomerFields stamp: 'p 6/26/2023 21:38:39'!
PASSED!

!testRun: #ImportTest #test04notEnoughOrMoreAddressFields stamp: 'p 6/26/2023 21:38:39'!
PASSED!

!testRun: #ImportTest #test05addressBeforeCustomer stamp: 'p 6/26/2023 21:38:39'!
PASSED!

!testRun: #ImportTest #test06IsNotCustomerNorAddress stamp: 'p 6/26/2023 21:38:39'!
FAILURE!

!testRun: #ImportTest #test07adjacentCommas stamp: 'p 6/26/2023 21:38:39'!
PASSED!

!testRun: #ImportTest #test06IsNotCustomerNorAddress stamp: 'p 6/26/2023 21:38:39'!
FAILURE!
!ImportTest methodsFor: 'test data' stamp: 'p 6/26/2023 21:39:25'!
importDataWithInvalidEntryType

	^ ReadStream on: 'X,Pepe,Sanchez,D,22333444'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'p 6/26/2023 21:39:25' prior: 50628687!
test06IsNotCustomerNorAddress
	
	self assert: [ CustomerImporter valueFrom: self importDataWithInvalidEntryType into: session. ]
	       raises: CustomerImporter invalidTypeOfEntryErrorDescription.
! !

!methodRemoval: ImportTest #importDataWithNotACustomerNorAnAddress stamp: 'p 6/26/2023 21:39:25'!
importDataWithNotACustomerNorAnAddress

	^ ReadStream on: 'X,Pepe,Sanchez,D,22333444'!
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 21:39:40'!
test06invalidEntryType
	
	self assert: [ CustomerImporter valueFrom: self importDataWithInvalidEntryType into: session. ]
	       raises: CustomerImporter invalidTypeOfEntryErrorDescription.
! !

!methodRemoval: ImportTest #test06IsNotCustomerNorAddress stamp: 'p 6/26/2023 21:39:40'!
test06IsNotCustomerNorAddress
	
	self assert: [ CustomerImporter valueFrom: self importDataWithInvalidEntryType into: session. ]
	       raises: CustomerImporter invalidTypeOfEntryErrorDescription.
!

!testRun: #ImportTest #test06invalidEntryType stamp: 'p 6/26/2023 21:39:41'!
FAILURE!

!testRun: #ImportTest #test06invalidEntryType stamp: 'p 6/26/2023 21:39:41'!
FAILURE!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 21:40:02' prior: 50628620!
raiseInvalidEntryTypeError

	self error: self class invalidTypeOfEntryErrorDescription.! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 21:40:05'!
PASSED!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 21:40:05'!
PASSED!

!testRun: #ImportTest #test03notEnoughOrMoreCustomerFields stamp: 'p 6/26/2023 21:40:05'!
PASSED!

!testRun: #ImportTest #test04notEnoughOrMoreAddressFields stamp: 'p 6/26/2023 21:40:06'!
PASSED!

!testRun: #ImportTest #test05addressBeforeCustomer stamp: 'p 6/26/2023 21:40:06'!
PASSED!

!testRun: #ImportTest #test06invalidEntryType stamp: 'p 6/26/2023 21:40:06'!
PASSED!

!testRun: #ImportTest #test07adjacentCommas stamp: 'p 6/26/2023 21:40:06'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 21:41:20' prior: 50628607!
importRecord

	(self isCustomerRecord) ifTrue: [ 
		self raiseErrorIfRecordSizeIsNot: 5.
		self importCustomer.
		^ self ].
	
	(self isAddressRecord) ifTrue: [
		self raiseErrorIfAddressFoundBeforeCustomer.
		self raiseErrorIfRecordSizeIsNot: 6. 
		self importAddress.
		^ self ].
	
	self raiseInvalidEntryTypeError.! !
!CustomerImporter class methodsFor: 'instance creation' stamp: 'p 6/26/2023 21:47:37' prior: 50628115!
from: aReadStream into: aSession
	
	(aReadStream isNil) ifTrue: [ self error: self nilStreamErrorDescription ].
	(aReadStream isEmpty) ifTrue: [ self error: self emptyStreamErrorDescription ].
	^ self new initializeFrom: aReadStream into: aSession! !
!CustomerImporter class methodsFor: 'instance creation' stamp: 'p 6/26/2023 21:48:11'!
nilStreamErrorDescription
	
	^ 'Stream is nil >>:(('! !
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 21:49:26'!
test08nilStream
	
	self assert: [ CustomerImporter valueFrom: self validImportData into: session. ]
	       raises: CustomerImporter nilStreamErrorDescription.
! !

!testRun: #ImportTest #test08nilStream stamp: 'p 6/26/2023 21:49:28'!
FAILURE!

!testRun: #ImportTest #test08nilStream stamp: 'p 6/26/2023 21:49:28'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 21:49:43' prior: 50628824!
test08nilStream
	
	self assert: [ CustomerImporter valueFrom: nil into: session. ]
	       raises: CustomerImporter nilStreamErrorDescription.
! !

!testRun: #ImportTest #test08nilStream stamp: 'p 6/26/2023 21:49:45'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 21:49:46'!
PASSED!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 21:49:46'!
PASSED!

!testRun: #ImportTest #test03notEnoughOrMoreCustomerFields stamp: 'p 6/26/2023 21:49:46'!
PASSED!

!testRun: #ImportTest #test04notEnoughOrMoreAddressFields stamp: 'p 6/26/2023 21:49:46'!
PASSED!

!testRun: #ImportTest #test05addressBeforeCustomer stamp: 'p 6/26/2023 21:49:46'!
PASSED!

!testRun: #ImportTest #test06invalidEntryType stamp: 'p 6/26/2023 21:49:46'!
PASSED!

!testRun: #ImportTest #test07adjacentCommas stamp: 'p 6/26/2023 21:49:46'!
PASSED!

!testRun: #ImportTest #test08nilStream stamp: 'p 6/26/2023 21:49:46'!
PASSED!
!CustomerImporter class methodsFor: 'error description' stamp: 'p 6/26/2023 21:50:24' prior: 50628820!
nilStreamErrorDescription
	
	^ 'Stream is nil >>>:((('! !
!ImportTest methodsFor: 'test data' stamp: 'p 6/26/2023 21:54:01'!
importDataWithValidFirstLetterButInvalidType

	^ ReadStream on: 'Customer,Pepe,Sanchez,D,22333444'! !
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 21:54:31'!
test08validFirstLetterButInvalidType
	
	self assert: [ CustomerImporter valueFrom: self importDataWithValidFirstLetterButInvalidType into: session. ]
	       raises: CustomerImporter invalidTypeOfEntryErrorDescription.
! !

!testRun: #ImportTest #test08validFirstLetterButInvalidType stamp: 'p 6/26/2023 21:54:33'!
FAILURE!

!testRun: #ImportTest #test08validFirstLetterButInvalidType stamp: 'p 6/26/2023 21:54:33'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'p 6/26/2023 21:54:43'!
test09validFirstLetterButInvalidType
	
	self assert: [ CustomerImporter valueFrom: self importDataWithValidFirstLetterButInvalidType into: session. ]
	       raises: CustomerImporter invalidTypeOfEntryErrorDescription.
! !

!methodRemoval: ImportTest #test08validFirstLetterButInvalidType stamp: 'p 6/26/2023 21:54:43'!
test08validFirstLetterButInvalidType
	
	self assert: [ CustomerImporter valueFrom: self importDataWithValidFirstLetterButInvalidType into: session. ]
	       raises: CustomerImporter invalidTypeOfEntryErrorDescription.
!

!testRun: #ImportTest #test09validFirstLetterButInvalidType stamp: 'p 6/26/2023 21:54:44'!
FAILURE!

!testRun: #ImportTest #test09validFirstLetterButInvalidType stamp: 'p 6/26/2023 21:54:44'!
FAILURE!
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 21:55:09' prior: 50627286!
isAddressRecord

	^ (record first = 'A')! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'p 6/26/2023 21:55:13' prior: 50627253!
isCustomerRecord

	^ (record first = 'C')! !

!testRun: #ImportTest #test01Import stamp: 'p 6/26/2023 21:55:16'!
PASSED!

!testRun: #ImportTest #test02Empty stamp: 'p 6/26/2023 21:55:16'!
PASSED!

!testRun: #ImportTest #test03notEnoughOrMoreCustomerFields stamp: 'p 6/26/2023 21:55:16'!
PASSED!

!testRun: #ImportTest #test04notEnoughOrMoreAddressFields stamp: 'p 6/26/2023 21:55:16'!
PASSED!

!testRun: #ImportTest #test05addressBeforeCustomer stamp: 'p 6/26/2023 21:55:16'!
PASSED!

!testRun: #ImportTest #test06invalidEntryType stamp: 'p 6/26/2023 21:55:16'!
PASSED!

!testRun: #ImportTest #test07adjacentCommas stamp: 'p 6/26/2023 21:55:16'!
PASSED!

!testRun: #ImportTest #test08nilStream stamp: 'p 6/26/2023 21:55:16'!
PASSED!

!testRun: #ImportTest #test09validFirstLetterButInvalidType stamp: 'p 6/26/2023 21:55:16'!
PASSED!

----SNAPSHOT----(26 June 2023 21:57:08) CuisUniversity-5832.image priorSource: 9366758!